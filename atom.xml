<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MeiMeiBlog</title>
  
  <subtitle>welcome</subtitle>
  <link href="http://tymblog.yuzhiboliuhua.cn/atom.xml" rel="self"/>
  
  <link href="http://tymblog.yuzhiboliuhua.cn/"/>
  <updated>2026-02-19T06:42:53.186Z</updated>
  <id>http://tymblog.yuzhiboliuhua.cn/</id>
  
  <author>
    <name>大鱼飞九草</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity之音效系统</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/e1e8becf.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/e1e8becf.html</id>
    <published>2026-02-07T11:36:00.000Z</published>
    <updated>2026-02-19T06:42:53.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="音频文件导入"><a href="#音频文件导入" class="headerlink" title="音频文件导入"></a>音频文件导入</h1><ul><li>常用格式：<code>wav</code>、<code>mp3</code>、<code>ogg</code>、<code>aiff</code></li></ul><h1 id="音效系统的组成"><a href="#音效系统的组成" class="headerlink" title="音效系统的组成"></a>音效系统的组成</h1><p>音效系统由两个脚本组成：<em>Audio Source音频源</em>和<em>AudioListener音频监听</em>。</p><ol><li>Audio Source 音频源</li></ol><ul><li><strong>AudioClip</strong>：音频文件</li><li>Output：输出装置。默认输出到场景中的音频监听器（MainCamera上的Audio Listener），可以更改为输出到混音器</li><li><strong>Mute</strong>：静音开关</li><li>Bypass Effect：开关滤波器效果</li><li>Bypass Listener Effects：快速开关所有监听器</li><li>Bypass Reverb Zones：快速开关所有混响区</li><li><strong>Play On Awake</strong>：对象创建时就播放音乐</li><li><strong>Loop</strong>：循环</li><li><strong>Priority</strong>：优先级。很多音效同时播放时，优先级越高越不容易被覆盖</li><li><strong>Volume</strong>：音量大小</li><li><strong>Pitch</strong>：音高。游戏加速时可以使用</li><li>Stereo Pan：左右声道</li><li>Spatial Blend：近大远小的效果</li><li>Reverb Zone Mix：到混响区的输出信号量</li><li>3D Sound Settings：和Spatial Blend参数成正比应用</li></ul><ol start="2"><li>AudioListener 音频监听脚本</li></ol><p><strong>默认挂载在主摄像机上</strong>，一个用来收声的脚本，只用在主摄像机上有就可以了。</p><h1 id="代码控制音频源"><a href="#代码控制音频源" class="headerlink" title="代码控制音频源"></a>代码控制音频源</h1><ol><li>得到音频源脚本</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioSource audioSource = <span class="keyword">this</span>.GetComponent&lt;AudioSource&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>控制播放停止</li></ol><ul><li>播放音效</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audioSource.Play();</span><br></pre></td></tr></table></figure><p>也可以延迟播放，参数填延迟的秒数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audioSource.PlayDelayed(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>停止音效</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audioSource.Stop();</span><br></pre></td></tr></table></figure><ul><li>暂停音效</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audioSource.Pause();</span><br></pre></td></tr></table></figure><p>停止暂停和暂停后<code>Play</code>效果是一样的，都会继续播放当前的音效。</p><p>停止（<code>Stop</code>）会重置播放状态，暂停（<code>Pause</code>）会保留当前播放位置。</p><ol start="3"><li>检测音频源播放完毕</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(audioSource.isPlaying)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：一个<code>GameObject</code>可以挂载多个音效源脚本<code>AudioSource</code>，使用时要注意如果挂载多个，一定要自己管理他们，控制他们的播放、停止。</p>]]></content>
    
    
    <summary type="html">这篇文章记录了Unity中音效系统相关（未完待续）</summary>
    
    
    
    <category term="Unity/核心系统" scheme="http://tymblog.yuzhiboliuhua.cn/categories/Unity-%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
    <category term="音效系统" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>UGUI</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/eda74239.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/eda74239.html</id>
    <published>2026-01-31T05:28:00.000Z</published>
    <updated>2026-02-15T08:47:50.469Z</updated>
    
    <content type="html"><![CDATA[<p><code>UGUI</code>是Unity官方的<code>UI</code>系统，用于开发游戏内<strong>菜单</strong>、<strong>血条</strong>、<strong>按钮</strong>、<strong>背包</strong>等 2D UI 界面。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>使用：在<code>Hierarchy</code>窗口右键 -&gt; <code>UI</code> -&gt; <code>Scene</code>窗口选择<code>2D</code>，工具栏选择方框（<code>T</code>）</p></li><li><p>两个重要的对象：</p><ul><li><p><code>Canvas</code></p></li><li><p><code>EventSystem</code></p></li></ul></li></ul><p>这两个对象上还分别依附了<code>UGUI</code>的重要组件，如下：</p><p><em>Canvas</em></p><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td><code>Canvas</code> 画布组件</td><td>渲染<code>UI</code>控件</td></tr><tr><td><code>Canvas Scaler</code> 画布分辨率自适应组件</td><td>分辨率自适应</td></tr><tr><td><code>Graphic Raycaster</code> 射线事件交互组件</td><td>控制射线响应</td></tr><tr><td><code>RectTransform</code> <code>UI</code>对象位置锚点控制组件</td><td>控制位置和对齐方式</td></tr></tbody></table><p><em>EventSystem</em></p><table><thead><tr><th>组件名称</th><th>作用</th></tr></thead><tbody><tr><td><code>EventSystem</code> 玩家输入事件响应系统</td><td>监听玩家操作</td></tr><tr><td><code>Standalone Input Module</code> 独立输入模块组件</td><td>监听玩家操作</td></tr></tbody></table><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Canvas-画布组件"><a href="#Canvas-画布组件" class="headerlink" title="Canvas 画布组件"></a>Canvas 画布组件</h3><p><code>Canvas</code>组件用于<strong>渲染</strong>挂载在其上的所有子对象。</p><p>场景中允许有多个<code>Canvas</code>对象，用于分别管理不同画布的渲染方式、分辨率自适应方式等等。</p><ul><li>3种渲染方式</li></ul><table><thead><tr><th>渲染方式名称</th><th>表现形式</th></tr></thead><tbody><tr><td><code>Screen Space - Overlay</code> 屏幕空间 - 覆盖模式</td><td><code>UI</code>始终在前</td></tr><tr><td><code>Screen Space - Camera</code> 屏幕空间 - 摄像机模式</td><td><code>3D</code>物体可以显示在<code>UI</code>之前</td></tr><tr><td><code>World Space</code> 世界空间</td><td><code>3D</code>模式</td></tr></tbody></table><p>接下来是对3种渲染方式参数的详细讲解：</p><ol><li><em>Screen Space - Overlay 屏幕空间 - 覆盖模式</em></li></ol><ul><li>Pixel Perfect：是否开启无锯齿渲染效果（性能换效果）</li><li><strong>SortOrder</strong>：<code>Canvas</code>排序层编号，<strong>数字越小越先渲染</strong></li><li>TargetDisplay：<code>UI</code>效果要渲染到哪个目标设备上</li><li>Additional Shader Channels：其他着色器通道，决定着色器可以读取哪些内容</li></ul><ol start="2"><li><em>Screen Space - Camera 屏幕空间 - 摄像机模式</em></li></ol><ul><li><strong>RenderCamera</strong>：用于渲染的摄像机（不设置默认覆盖模式效果），<strong>建议专门用一个摄像机渲染<code>UI</code>（<code>UI</code>摄像机上的<code>Clear Flags</code>改为<code>Depth Only</code>）</strong></li><li>Plane Distance：<code>UI</code>平面在摄像机前方的距离，类似整体z轴</li><li>Sorting Layer：渲染所在层级</li><li>Order in Layer：在同一层时的渲染顺序</li></ul><p>其中，如果想让<code>3D</code>物体显示在<code>UI</code>之前，可以直接在该<code>UI</code>下创建该物体（记得改缩放大小），把层级<code>layer</code>改为<code>UI</code></p><ol start="3"><li><em>World Space 世界空间</em></li></ol><ul><li>EventCamera：用于处理<code>UI</code>事件的摄像机</li></ul><p>在这种模式下，<code>UI</code>可以看作<code>3D</code>物体处理。</p><h3 id="Canvas-Scaler-画布分辨率自适应组件"><a href="#Canvas-Scaler-画布分辨率自适应组件" class="headerlink" title="Canvas Scaler 画布分辨率自适应组件"></a>Canvas Scaler 画布分辨率自适应组件</h3><p><code>Canvas Scaler</code> 主要用于<code>UI</code>控件在不同分辨率下的<strong>大小自适应</strong>。</p><p><em><em>宽（高）</em> 缩放大小 &#x3D; 屏幕分辨率</em>*</p><ul><li>3种适配模式：</li></ul><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td><code>Constant Pixel Size</code> 恒定像素模式</td><td>无论屏幕大小如何，<code>UI</code>始终保持相同像素大小</td></tr><tr><td><code>Scale With Screen Size</code> 缩放模式</td><td>根据屏幕尺寸进行缩放</td></tr><tr><td><code>Constant Physical Size</code> 恒定物理模式（与恒定像素模式类似）</td><td>无论屏幕大小和分辨率如何，<code>UI</code>元素始终保持相同物理大小</td></tr></tbody></table><p>还有一种特殊的3D模式：当<code>Canvas</code>的渲染设置为<code>World Space</code>世界空间3D渲染模式时，<code>Canvas Scaler</code>就会自动变成<code>world</code>世界3D模式。</p><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td><code>World</code> 世界模式</td><td>3D模式</td></tr></tbody></table><p>接下来是对3种适配模式参数的详细讲解：</p><ol><li><em>Constant Pixel Size 恒定像素模式</em></li></ol><ul><li>Scale Factor：缩放系数</li><li>Reference Pixels Per Unit：单位参考像素，多少像素对应<code>Unity</code>中的一个单位（默认一个单位为100像素），该参数会与图片中的<code>Pixels Per Unit</code>这个参数一起参与计算。</li></ul><p><strong>恒定像素计算公式：</strong></p><p><strong>UI原始尺寸 &#x3D; 图片大小（像素）&#x2F; （Pixels Per Unit &#x2F; Reference Pixels Per Unit）</strong></p><ol start="2"><li><em>Scale With Screen Size 缩放模式</em></li></ol><ul><li><strong>Reference Resolution</strong>：参考分辨率（由美术给出），缩放模式下所有匹配模式都会基于参考分辨率进行自适应计算。<ul><li>PC端：<code>1920 x 1080</code></li></ul></li><li>Screen Match Mode：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式。<ul><li>Expand：拓展画布区域，可能有黑边</li><li>Shrink：裁剪画布区域，可能有裁剪</li><li><strong>Match Width Or Height</strong>：以宽高或者二者的平均值作为参考来缩放画布区域<ul><li>Match（0~1）<ul><li>Width（Match &#x3D; 0）：适用于竖屏游戏</li><li>Height（Match &#x3D; 1）：适用于横屏游戏</li></ul></li></ul></li></ul></li></ul><ol start="3"><li><em>Constant Physical Size 恒定物理模式</em></li></ol><p>在学习恒定物理模式的参数之前，要首先了解一个概念——<code>DPI</code><br>它是<code>Dots Per Inch</code>的缩写，即图像每英寸长度内的像素点数（即像素密度）。</p><ul><li>Physical Unit：物理单位，使用的物理单位种类（与1英寸的计算关系）</li><li>Fallback Screen DPI：备用DPI，当找不到设备DPI时，使用此值</li><li>Default Sprite DPI：默认图片DPI</li></ul><p>恒定物理模式的作用：因为<code>DPI</code>的值较高的细节更完整，尺寸也较大。所以用这个模式可以进行不同设备的调整。</p><ol start="4"><li><em>World 世界模式</em></li></ol><ul><li>Dynamic Pixels Per Unit：UI中动态创建的位图（例如文本）中，单位像素数（类似密度）</li></ul><h3 id="Graphic-Raycaster-射线事件交互组件"><a href="#Graphic-Raycaster-射线事件交互组件" class="headerlink" title="Graphic Raycaster 射线事件交互组件"></a>Graphic Raycaster 射线事件交互组件</h3><p><code>Graphic Raycaster</code>的意思是图形射线投射器，它是用于检测<code>UI</code>输入事件的射线发射器。</p><ul><li>Ignore Reversed Graphics：是否忽略反转图形</li><li><strong>Blocking Objects</strong>：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效）</li><li><strong>Blocking Mask</strong>：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效）</li></ul><h3 id="RectTransform-UI位置锚点组件"><a href="#RectTransform-UI位置锚点组件" class="headerlink" title="RectTransform UI位置锚点组件"></a>RectTransform UI位置锚点组件</h3><p><code>RectTransform</code>的意思是矩形变换。他继承于<code>Transform</code>，是专门用于处理<code>UI</code>元素位置大小相关的组件。与<code>Transform</code>不同的是，他在位置、角度、缩放的基础上加入了矩形相关的中心点、锚点、长宽等属性，可以更方便的控制其大小以及<strong>分辨率自适应中的位置适应</strong>。</p><ul><li><strong>Pivot</strong>：中心点（0~1）</li><li><strong>Anchors</strong>：相对<strong>父矩形</strong>锚点<ul><li>合成一点：相对与一个点的位置自适应<ul><li>Pos(X,Y,Z)：轴心点相对锚点的位置</li><li>Weidth&#x2F;Height：矩形的宽高</li></ul></li><li>分成四个箭头：各边的距离，大小自适应<ul><li>Left&#x2F;Right&#x2F;Bottom：矩形边缘相对于锚点的位置</li></ul></li></ul></li></ul><p>另外，左上角的方框点开可以快捷设置轴心点和锚点，其中，按住<code>shift</code>键，可以在设置锚点的同时设置轴心点；按住<code>Alt</code>键，可以同时设置的同时放置在相应位置。</p><ul><li>Rotation：围绕轴心点旋转的角度</li><li>Scale：缩放大小</li><li>右侧还有两个按钮：<ul><li>虚线框：Blueprint Mode(蓝图模式)，启用后编辑旋转和缩放不会影响矩形，只会影响显示内容</li><li>R：Raw Edit Mode(原始编辑模式)，启用后，改变轴心和锚点值不会改变矩形位置</li></ul></li></ul><h3 id="玩家输入响应相关的两个组件"><a href="#玩家输入响应相关的两个组件" class="headerlink" title="玩家输入响应相关的两个组件"></a>玩家输入响应相关的两个组件</h3><p>与玩家输入响应相关的两个组件分别是<code>EventSystem</code>和<code>Standalone Input Module</code>。</p><ol><li><code>EventSystem</code>意思是事件系统。它是用于管理玩家的输入事件并分发给各<code>UI</code>控件的，类似一个中转站。</li></ol><ul><li><strong>First Selected</strong>：首先选择的游戏对象，可以设置游戏一开始的默认选择</li><li><strong>Send Navigation Events</strong>：是否允许导航事件（AWSD键、回车键移动&#x2F;按下&#x2F;取消）</li><li>Drag Threshold：拖拽操作的阈值（移动多少像素算拖拽）</li></ul><ol start="2"><li><code>Standalone Input Module</code>意思是独立输入模块。它主要针对处理鼠标&#x2F;键盘&#x2F;控制器&#x2F;触屏的输入，输入的事件通过<code>EventSystem</code>进行分发，依赖于<code>EventSystem</code>组件。</li></ol><ul><li>Horizontal Axis、Vertical Axis、Submit Button、Cancel Button 都是对应Input管理器中的热键名</li><li>Input Actions Per Second：每秒允许键盘&#x2F;控制器输入的数量</li><li>Repeat Delay：重复操作生效的延迟时间</li><li>ForceModule Active：是否强制模块处于激活状态</li></ul><p><strong>值得一提的是，在运行状态下，<code>EventSystem</code>的<code>Inspector</code>窗口下方提供了调试用的打印信息，我们可以根据其中的信息来判断自己进入了哪个控件，从而判断控件是否被挡住。</strong></p><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>关于使用控件都需要引用命名空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br></pre></td></tr></table></figure><h3 id="三大基础控件"><a href="#三大基础控件" class="headerlink" title="三大基础控件"></a>三大基础控件</h3><p>三大基础控件包括<code>Image</code>图片、<code>Text</code>文本、<code>Rawimage</code>大图。</p><h4 id="Image-图片"><a href="#Image-图片" class="headerlink" title="Image 图片"></a>Image 图片</h4><p><code>Image</code>是图像控件，是<code>UGUI</code>中用于显示精灵图片的关键组件，除了背景图等大图，一般都使用<code>Image</code>来显示<code>UI</code>中的图片元素。</p><ol><li>参数相关</li></ol><ul><li>Source Image：图片来源，必须是<code>sprite</code></li><li>Color：颜色</li><li>Material：图像的材质</li><li><strong>Raycast Target</strong>：是否作为射线检测的目标</li><li><strong>Maskable</strong>：是否能被遮罩</li><li><strong>Image Type</strong>：图片类型<ul><li>Simple：普通模式。均匀的缩放整个图片</li><li><strong>Sliced</strong>：切片模式。9宫格拉伸，只拉伸中央十字区域<ul><li>Fill Center：中心是否填充</li><li>Pixel Per UnitMultiplier：每单位像素乘数</li></ul></li><li>Tiled：平铺模式。重复平铺中央部分</li><li><strong>Filed</strong>：填充模式。<strong>可以用来做血条、CD效果</strong></li></ul></li><li>Use Sprite Mesh：使用精灵网格，勾选后Unity会帮我们生成图片网格</li><li>Preserve Aspect：保持宽高比</li><li><strong>Set Native Size</strong>：设置为图片资源的原始大小</li></ul><ol start="2"><li>代码相关</li></ol><p>得到组件即成员：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Image img = <span class="keyword">this</span>.GetComponent&lt;Image&gt;();</span><br><span class="line">img.sprite = Resources.Load&lt;Sprite&gt;(<span class="string">&quot;&quot;</span>); <span class="comment">// 参数填Resources文件夹下图片名字</span></span><br></pre></td></tr></table></figure><h4 id="Text-文本控件"><a href="#Text-文本控件" class="headerlink" title="Text 文本控件"></a>Text 文本控件</h4><p><code>Text</code>是文本组件，是<code>UGUI</code>中用于显示文本的关键组件。</p><ol><li>参数相关</li></ol><ul><li>Text：文本显示内容</li><li>Front：字体 （找字体的路径：<code>C:\Windows\Fronts</code>）</li><li>FrontStyle：字体样式</li><li>Front Size：字体大小</li><li>Line Spacing：行之间的垂直间距</li><li>Rich Text：是否开启富文本</li><li>Alignment：对齐方式</li><li>Align By Geometry：使用字形集合形状范围进行水平对齐，而不是字形指标</li><li><strong>Horizontal Overflow</strong>：横向溢出模式<ul><li>Wrap：包裹模式。超出范围自动换行</li><li>Overflow：溢出模式。</li></ul></li><li><strong>Vertical Overflow</strong>：竖向溢出模式<ul><li>Truncate：裁剪模式。超出范围不显示</li><li>Overflow：溢出模式。</li></ul></li><li><strong>Best Fit</strong>：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整字体大小。</li></ul><ol start="2"><li>富文本</li></ol><p>在输入文本的地方自己通过输入特殊符号标记来改变字体样式。</p><ul><li>加粗</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;文本内容&lt;/b&gt;</span><br></pre></td></tr></table></figure><ul><li>斜体</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i&gt;文本内容&lt;/i&gt;</span><br></pre></td></tr></table></figure><ul><li>大小</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;size=<span class="number">50</span>&gt;文本内容&lt;/size&gt;</span><br></pre></td></tr></table></figure><ul><li>颜色</li></ul><p>控制颜色有两种方式。</p><p>第一种是通过十六进制来写，其中每两位对应一种颜色，对应关系是RGBA(red green blue 阿尔法通道)，输入<code>ff</code>就是默认开启，<code>00</code>就是关闭，下面是一个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;color=<span class="meta">#00ff00ff&gt;文本内容&lt;/color&gt;</span></span><br></pre></td></tr></table></figure><p>最终显示的颜色就是绿色。</p><p>还有一种方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;color=red&gt;文本内容&lt;/color&gt;</span><br></pre></td></tr></table></figure><p>以下是Unity官方支持的颜色对照表：</p><p><a href="https://docs.unity.cn/cn/2020.3/Manual/StyledText.html">富文本 - Unity 手册</a></p><ol start="3"><li>边缘线和阴影</li></ol><p>可以通过添加脚本组件来为字体加上边缘线和阴影。</p><ul><li>边缘线：<code>Outline</code></li><li>阴影：<code>Shadow</code></li></ul><ol start="4"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Text txt = <span class="keyword">this</span>.GetComponent&lt;Text&gt;();</span><br><span class="line">txt.text = <span class="string">&quot;大鱼飞九草&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="RawImage-原始图片（大图控件）"><a href="#RawImage-原始图片（大图控件）" class="headerlink" title="RawImage 原始图片（大图控件）"></a>RawImage 原始图片（大图控件）</h4><p><code>RawImage</code>是原始图像控件。是<code>UGUI</code>中用于显示任何纹理图片的关键组件。</p><p>它和<code>Image</code>的区别是：一般<code>RawImage</code>用于显示大图（背景图，不需要打入图集的图片、网络下载的图片）</p><ol><li>参数相关</li></ol><ul><li>Texture：图像纹理</li><li>UV Rect：图像在UI矩形内的偏移和大小<ul><li>X\Y：位置偏移，取值0~1</li><li>W\H：大小偏移，取值0~1</li></ul></li></ul><ol start="2"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RawImage raw = <span class="keyword">this</span>.GetComponent&lt;RawImage&gt;();</span><br><span class="line">raw.texture = Resources.Load&lt;Texture&gt;(<span class="string">&quot;&quot;</span>); <span class="comment">// 参数填Resources文件夹下图片名字</span></span><br></pre></td></tr></table></figure><h3 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h3><h4 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h4><p><code>Button</code>是按钮组件，是<code>UGUI</code>中用于处理玩家按钮相关交互的关键组件。</p><p><code>Button</code>的组成如下：</p><ul><li>Button（上面挂了<code>Image</code>组件）<ul><li>Text</li></ul></li></ul><ol><li>参数相关</li></ol><ul><li>Interactable：是否接受输入</li><li>Transition：响应用户输入的过渡效果<ul><li>None：没有状态变化效果</li><li><strong>ColorTint</strong>：有颜色变化效果<ul><li><strong>TargetGraphic</strong>：控制的目标图形</li><li><strong>Normal Color</strong>：正常状态的颜色</li><li>Highlighted Color：鼠标进入时的高亮颜色</li><li><strong>Pressed Color</strong>：按下颜色</li><li>Selected Color：选中的颜色</li><li>Disabled Color：禁用时的颜色</li><li>Color Multiplier：颜色倍增器，过渡颜色乘以该值</li><li><strong>FadeDuration</strong>：从一个状态到另一个状态所需要的时间</li></ul></li><li>Sprite Swap：用图片表示变化效果</li><li>Animation：用动画表示变化效果</li></ul></li><li>Navigation：导航模式。WASD键盘控制的使用<ul><li>None：无键盘导航</li><li>Horizontal：水平导航</li><li>Vertical：竖直导航</li><li>Automatic：自动导航</li><li>Explicit：自定义按键</li><li>Visualize：可以在Scence窗口中看到导航连线</li></ul></li><li>OnClick：单击执行的函数列表</li></ul><ol start="2"><li>代码相关</li></ol><p>得到按钮组件即成员：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Button btn = <span class="keyword">this</span>.GetComponent&lt;Button&gt;();</span><br><span class="line"><span class="comment">// 改变用户输入的过渡效果（枚举）</span></span><br><span class="line">btn.transition = Selectable.Transition.None;</span><br></pre></td></tr></table></figure><p>也可以得到上面的<code>Image</code>组件，再控制。</p><ol start="3"><li>监听点击事件</li></ol><p>监听点击事件有两种方式：拖脚本和代码添加。</p><p><em>拖脚本</em></p><p>需要在OnClick上添加一个对象，上面再关联对应的脚本上的函数。</p><p><em>代码添加</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：无参无返回值值的委托函数</span></span><br><span class="line">btn.onClick.AddListener();</span><br></pre></td></tr></table></figure><p><em>代码移除</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：无参无返回值值的委托函数</span></span><br><span class="line">btn.onClick.RemoveListener();</span><br></pre></td></tr></table></figure><p>还有一种可以移除所有监听函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onClick.RemoveAllListener();</span><br></pre></td></tr></table></figure><p>另外，还有异形按钮。我们需要使异形按钮被准确的点击可以这样操作：</p><p><em>方法1：添加子对象</em></p><ol><li>创建一个<code>Image</code>作为按钮范围的显示</li><li>为<code>Image</code>创建一个子对象按钮，更改透明度，将按钮的<code>Target Graphic</code>改为父对象，使其有颜色变化</li><li>在Button下方创建很多<code>Image</code>拼成异形图案</li></ol><p><em>方法2：通过代码改变图片的透明度响应阈值</em></p><ol><li>修改图片参数：开启Read&#x2F;Write Enabled开关</li><li>通过代码修改图片的响应阈值（当像素点的alpha值小于了该值，就不会被射线检测了）</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Image img;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">img.alphaHitTestMinimumThreshold = <span class="number">0.1f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式更准确，但是更浪费性能。</p><h4 id="Toggle-单（多）选框"><a href="#Toggle-单（多）选框" class="headerlink" title="Toggle 单（多）选框"></a>Toggle 单（多）选框</h4><p><code>Toggle</code>是开关组件，是<code>UGUI</code>中用于处理玩家单选框、多选框相关交互的关键组件。</p><p><code>Toggle</code>组件<strong>默认是多选框</strong>，可以通过配合<code>ToggleGroup</code>组件制作为单选框。</p><p><code>Toggle</code>的组成如下：</p><ul><li>Toggle<ul><li>Background<ul><li>Checkmark</li></ul></li><li>Label</li></ul></li></ul><ol><li>参数相关</li></ol><ul><li>IsOn：当前是否处于打开状态</li><li>Toggle Transition：在开关值变化时的过渡方式<ul><li>None：无任何过渡</li><li>Fade：淡入淡出</li></ul></li><li>Graphic：表示选中状态的图片</li><li>Group：单选框分组</li><li>OnValueChanged：开关状态变化时执行的函数列表</li></ul><p>下面是<strong>制作单选框</strong>的思路：</p><p>首先，在Hierarchy窗口下的Canvas中创建一个<code>ToggleGroup</code>空物体，用于管理一组<code>Toggle</code>对象。为这个空物体添加一个<code>Toggle Group</code>组件</p><p>然后，将每一个<code>Toggle</code>对象上的Group参数都选择为<code>ToggleGroup</code></p><p>需要注意的是：组件<code>Toggle Group</code>上有一个参数——<code>Allow Switch Off</code>，表示是否允许不选中任何一个单选框</p><ol start="2"><li>代码相关</li></ol><p>得到组件即成员：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toggle tog = <span class="keyword">this</span>.GetComponent&lt;Toggle&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>监听事件</li></ol><p>与<code>Button</code>的差不多，但是有一个<code>bool</code>参数</p><p>以下是一个改变值的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tog.onValueChanged.AddListener((b) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="InputField-文本输入控件"><a href="#InputField-文本输入控件" class="headerlink" title="InputField 文本输入控件"></a>InputField 文本输入控件</h4><p><code>InputField</code>是输入字段组件，是<code>UGUI</code>中用于处理玩家文本输入相关交互的关键组件。</p><p><code>InputField</code>的组成如下：</p><ul><li>InputField（上面有一个Image组件）<ul><li>Placeholder：默认提示字样</li><li>Text</li></ul></li></ul><ol><li>参数相关</li></ol><ul><li><strong>TextComponent</strong>：用于关联显示输入内容的文本组件</li><li><strong>Text</strong>：输入框的起始默认值</li><li><strong>Character Limit</strong>：可以输入字符长度的最大值</li><li><strong>Content Type</strong>：输入的字符类型限制<ul><li>Standard：标准模式。可以输入任何字符</li><li>Autocorrected：自动更正模式</li><li>Integer Number：整数模式</li><li>Decimal Number：十进制数模式</li><li>Alphanumeric：字母数字模式。只能输入字母和数字</li><li>Name：名字模式。自动将每个单词首字母大写</li><li>Email Address：邮箱地址模式。允许最多输入一个<code>@</code>符号组成的字符和数字字符串</li><li>PassWord：密码模式。用星号隐藏输入的字符，允许使用符号</li><li>Pin：别针模式。用星号隐藏输入的字符，只允许输入整数</li><li>Custom：自定义模式</li></ul></li><li><strong>Line Type</strong>：行类型，定义文本格式<ul><li>Single Line：只允许单行显示</li><li>Multi Line Submit：允许使用多行。仅在需要时使用新的一行</li><li>Multi Line NewLine：允许使用多行。用户可以按回车键空行</li></ul></li><li>Placeholder：默认文本内容</li><li>Caret Blink Rate：光标闪烁速率</li><li>Caret Width：光标宽</li><li>Custom Caret Color：自定义光标颜色</li><li>Selection Color：批量选中的背景颜色</li><li>Hide Mobile Input：隐藏移动设备屏幕上的键盘，仅适用于ios</li><li>Read Only：只读，不能改</li></ul><ol start="2"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputField input = <span class="keyword">this</span>.GetComponnet&lt;InputField&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>监听事件</li></ol><p>与<code>Button</code>的差不多，但是有一个<code>string</code>参数</p><p>以下是一个改变值的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input.onValueChanged.AddListener((str) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Slider-滑动条"><a href="#Slider-滑动条" class="headerlink" title="Slider 滑动条"></a>Slider 滑动条</h4><p><code>Slider</code>是滑动条组件。是<code>UGUI</code>中用于处理滑动条相关交互的关键组件。</p><p><code>Slider</code>的组成如下：</p><ul><li>Slider<ul><li>Background 背景图</li><li>Fill Area 填充图<ul><li>Fill</li></ul></li><li>Handle Slide Area 滑动块<ul><li>Handle</li></ul></li></ul></li></ul><ol><li>参数相关</li></ol><ul><li>FillRect：用于填充的进度条图形</li><li>Handle Rect：滑动块图形</li><li>Direction：滑动条值增加的方向</li><li>Min Value\Max Value\Value：滑动条的数值</li><li>Whole Numbers：是否约束为整数值变化</li><li>OnValueChanged：滑动条值改变时执行的函数列表</li></ul><ol start="2"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Slider s = <span class="keyword">this</span>.GetComponent&lt;Slider&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>监听事件</li></ol><p>与<code>Button</code>的差不多，但是有一个<code>float</code>参数</p><p>以下是一个改变值的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.onValueChanged.AddListener((v) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="ScrollBar-滚动条"><a href="#ScrollBar-滚动条" class="headerlink" title="ScrollBar 滚动条"></a>ScrollBar 滚动条</h4><p><code>ScrollBar</code>是滚动条组件。是<code>UGUI</code>中用于处理滚动条相关交互的关键组件。</p><p><code>ScrollBar</code>的组成如下：</p><ul><li>ScrollBar（上面有一个Image组件）<ul><li>Sliding Area 滑动块</li></ul></li></ul><p>一般情况都是配合<strong>ScrollView 滚动视图</strong>来使用。</p><ol><li>相关参数</li></ol><ul><li>Handle Rect：滚动块</li><li>Direction：滚动条值增加的方向</li><li>Value：滚动条初始位置值（0~1）</li><li>Size：滚动块在条中的比例大小（0~1）</li><li>Number Of Steps：允许可以滚动多少次</li><li>OnValueChanged：滚动条值改变时执行的函数列表</li></ul><ol start="2"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScrollBar sb = <span class="keyword">this</span>.GetComponent&lt;ScrollBar&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>监听事件</li></ol><p>与<code>Button</code>的差不多，但是有一个<code>float</code>参数</p><p>以下是一个改变值的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sb.onValueChanged.AddListener((v) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="ScrollView-滚动视图"><a href="#ScrollView-滚动视图" class="headerlink" title="ScrollView 滚动视图"></a>ScrollView 滚动视图</h4><p><code>ScrollView</code>是滚动视图。但是其上的关键组件是<code>ScrollRect</code>，<code>ScrollRect</code>是<code>UGUI</code>中用于处理滚动视图相关交互的关键组件。</p><p><code>ScrollRect</code>的组成如下：</p><ul><li>ScrollRect（上面有一个Image组件）<ul><li>Viewport<ul><li>Content 控制滚动视图可视范围和内容显示</li></ul></li><li>Scrollbar Horizontal</li><li>Scrollbar Vertical</li></ul></li></ul><ol><li>参数相关</li></ol><ul><li><strong>Content</strong>：滚动视图的大小，他的尺寸有多大就能拖多远</li><li><strong>Horizontal</strong>：启用水平滚动</li><li><strong>Vertical</strong>：启用竖直滚动</li><li>Movement Type：滚动视图元素的运动类型。主要控制拖动时的反馈效果<ul><li>Unrestricted（一般不使用）。不受限制，随便拖动</li><li><strong>Elastic（常用）</strong>：回弹效果。滚出边缘后会弹回边界<ul><li>Elasticity：回弹系数。值越大回弹越慢</li></ul></li><li>Clamped：夹紧效果。没有回弹效果</li></ul></li><li>Inertia：移动惯性<ul><li>Deceleration Rate：减速率（0~1），0没有惯性，1不会停止</li></ul></li><li>Scroll Sensitivity：滚轮和触摸板的滚动事件敏感性</li><li>Viewport：滚动视图视口对象</li><li>Horizontal（Vertical） Scrollbar：水平（竖直）滚动条<ul><li>Visibility：是否在不需要时自动隐藏<ul><li>Permanent：一直显示滚动条</li><li>Auto Hide：自动隐藏滚动条</li><li>Auto Hide And Expand Viewport：自动隐藏滚动条并且自动拓展内容视口</li></ul></li><li>Spacing：滚动条和视口之间的间隔空间</li></ul></li><li>OnValueChanged：滚动视图位置改变时执行的函数列表</li></ul><p><strong>注意：如果删除滚动条需要将<code>Inspector</code>窗口上的关联滚动条的地方置为<code>None</code>，并且将视图窗口手动拖满。</strong></p><ol start="2"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScrollRect sr = <span class="keyword">this</span>.GetComponent&lt;ScrollRect&gt;();</span><br></pre></td></tr></table></figure><p>另外，可以通过得到<code>content</code>来改变内容的大小：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sr.content.sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>也可以通过这种方式来改变当前的位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：x的位置</span></span><br><span class="line"><span class="comment">// 参数2：y的位置</span></span><br><span class="line">sr.normalizedPosition = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>监听事件</li></ol><p>与<code>Button</code>的差不多，但是有一个<code>Vector2</code>参数</p><p>以下是一个改变值的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sr.onValueChanged.AddListener((vec) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="DropDown-下拉列表"><a href="#DropDown-下拉列表" class="headerlink" title="DropDown 下拉列表"></a>DropDown 下拉列表</h4><p><code>DropDown</code>是下拉列表。<code>DropDown</code>是<code>UGUI</code>中用于处理下拉列表相关交互的关键组件。</p><p><code>DropDown</code>的组成如下：</p><ul><li>DropDown（上面有一个Image组件）<ul><li>Label</li><li>Arrow 箭头</li><li>Template 选单</li></ul></li></ul><ol><li>参数相关</li></ol><ul><li>Template：关联下拉列表对象</li><li>Caption Text：关联显示当前选择内容的文本组件</li><li>Caption Image：关联显示当前选择内容的图片组件</li><li>Item Text：关联下拉列表选项用的文本控件</li><li>Item Image：关联下拉列表选项用的图片控件</li><li>Value：当前所选选项的索引值</li><li>Alpha Fade Speed：下拉列表窗口淡入淡出的速度</li><li>Options：存在的选项列表</li></ul><ol start="2"><li>代码相关</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DropDown dd = <span class="keyword">this</span>.GetComponent&lt;DropDown&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前内容</span></span><br><span class="line">dd.options[dd.<span class="keyword">value</span>];</span><br></pre></td></tr></table></figure><ol start="3"><li>监听事件</li></ol><p>与<code>Button</code>的差不多，但是有一个<code>int</code>参数</p><p>以下是一个改变值的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd.onValueChanged.AddListener((index) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h2><p><strong>图集</strong>就是把很多小图片打包成一张大图，核心是为了优化性能、减少 <code>Draw Call</code>。其中，<code>Draw Call</code>可以理解为依次绘制请求，cpu每帧能发起的 <code>DC</code> 数量有限，所以<code>DC</code>越多，就越卡。</p><p>因此，我们可以通过打图集来提高性能。</p><p><strong>详情参见：</strong><code>Unity核心 - 2D图片相关 - Sprite 精灵图片 - Sprite Atlas 精灵图集制作</code></p><p>看<code>Draw Call</code>的方法：查看在<code>Game</code>窗口中的<code>Stats</code>中的<code>Batches</code>（初始为2）</p><p><strong>注意：如果一张图集之间插入了别的图或者文本，就要多渲染一次。</strong></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="UI事件监听接口"><a href="#UI事件监听接口" class="headerlink" title="UI事件监听接口"></a>UI事件监听接口</h2><p>使用<strong>UI事件监听接口</strong>有2个好处。其一是可以处理<strong>长按、双击、拖拽</strong>等功能；另一个是能让<code>Image</code>和<code>Text</code>和<code>RawImage</code><strong>三大基础控件能响应</strong>玩家输入。</p><p>需要引用一个命名空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br></pre></td></tr></table></figure><h3 id="常用的事件接口"><a href="#常用的事件接口" class="headerlink" title="常用的事件接口"></a>常用的事件接口</h3><p>以下是一些常用的事件接口：</p><table><thead><tr><th>接口名</th><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td><code>IPointerEnterHandler</code></td><td><code>OnPointerEnter</code></td><td>鼠标进入</td></tr><tr><td><code>IPointerExitHandler</code></td><td><code>OnPointerExit</code></td><td>鼠标离开</td></tr><tr><td><code>IPointerDownHandler</code></td><td><code>OnPointerDown</code></td><td>鼠标按下</td></tr><tr><td><code>IPointerUpHandler</code></td><td><code>OnPointerUp</code></td><td>鼠标抬起</td></tr><tr><td><code>IPointerClickHandler</code></td><td><code>OnPointerClick</code></td><td>鼠标点击</td></tr><tr><td><code>IBeginDragHandler</code></td><td><code>OnBeginDrag</code></td><td>开始拖拽</td></tr><tr><td><code>IDragHandler</code></td><td><code>OnDrag</code></td><td>拖拽中</td></tr><tr><td><code>IEndDragHandler</code></td><td><code>OnEndDrag</code></td><td>结束拖拽</td></tr></tbody></table><p><strong>以上方法也适用于触屏。</strong></p><p>想使用这些事件只需继承上述对应的接口，实现里面的函数，并且将脚本挂载在相应对象上即可。</p><p>还有一些不常用的事件接口，这里不做举例。</p><p>值得注意的是，上面提到的所有接口里的函数都有一个参数<code>PointEventData eventData</code>，接下俩详细讲解这个参数相关的知识。</p><ol><li><p>父类：<code>BaseEventData</code></p></li><li><p>参数</p></li></ol><ul><li>pointerId：鼠标哪个键按下（左：-1 中：-3 右：-2）</li><li>position：当前鼠标位置（屏幕坐标系），拖拽也适用</li><li>pressPosition：当前鼠标位置（屏幕坐标系），拖拽不适用</li><li>delta：鼠标指针移动增量</li><li>clickCount：连击次数</li><li>clickTime：点击时间</li><li>pressEventCamera：最后一个<code>OnPointerPress</code>按下事件关联的摄像机</li><li>enterEventCamera：最后一个<code>OnPointerEnter</code>进入事件关联的摄像机</li></ul><h3 id="EventTrigger-事件触发器"><a href="#EventTrigger-事件触发器" class="headerlink" title="EventTrigger 事件触发器"></a>EventTrigger 事件触发器</h3><p><code>EventTrigger</code> 事件触发器是一个脚本组件，其上集成了以上提到的所有事件接口，可以让我们更方便的为控件添加事件监听。</p><p>有两种使用方法：</p><p><em>拖曳脚本关联</em><br> 在<code>Inspector</code>窗口选择要使用的事件接口，关联相应的面板对象，选择要实现的函数。</p><p><em>通过代码添加</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">program</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> EventTrigger et;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 申明一个希望监听的事件对象</span></span><br><span class="line">EventTrigger.Entry entry = <span class="keyword">new</span> EventTrigger.Entry(); <span class="comment">// 其中，Entry是一个内部类</span></span><br><span class="line"><span class="comment">// 初始化申明事件的类型</span></span><br><span class="line">entry.eventID = EventTriggerType.PointerUp;</span><br><span class="line"><span class="comment">// 监听回调函数关联</span></span><br><span class="line">entry.callback.AddListener((data) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 抬起后的具体逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// triggers是一个List&lt;&gt;</span></span><br><span class="line">et.triggers.Add(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="屏幕坐标转UI相对坐标"><a href="#屏幕坐标转UI相对坐标" class="headerlink" title="屏幕坐标转UI相对坐标"></a>屏幕坐标转UI相对坐标</h2><p>详情参见 游戏开发 - 坐标转换相关 - 屏幕坐标 -&gt; UI本地坐标</p><h2 id="Mask-遮罩"><a href="#Mask-遮罩" class="headerlink" title="Mask 遮罩"></a>Mask 遮罩</h2><p>遮罩是在不改变图片的情况下，让图片只显示一部分。</p><p>通过在父对象上添加<code>Mask</code>组件即可遮罩其子对象。</p><p><strong>注意：</strong></p><ol><li>想要被遮罩的<code>Image</code>需要勾选<code>Maskable</code></li><li>只要父对象添加了<code>Mask</code>组件，那么所有的UI子对象都会被遮罩</li><li>遮罩父对象图片中，不透明的地方显示，透明的地方被遮罩</li></ol><p>另外，如果<strong>不想让遮罩图片显示出来</strong>的话只需取消<code>Mask</code>组件上的<code>Show Mask Graphic</code></p><h2 id="模型和粒子显示在UI之前"><a href="#模型和粒子显示在UI之前" class="headerlink" title="模型和粒子显示在UI之前"></a>模型和粒子显示在UI之前</h2><h3 id="模型显示在UI之前"><a href="#模型显示在UI之前" class="headerlink" title="模型显示在UI之前"></a>模型显示在UI之前</h3><p><em>方法1：直接用摄像机渲染3D物体</em></p><ol><li><code>Canvas</code>渲染模式改为摄像机模式或者世界模式</li><li>专门用一个摄像机来进行UI和要出现在UI前物体的渲染</li><li>要渲染的3D物体层级必须是<code>UI</code>层，也要改变缩放大小</li></ol><p><em>方法2：将3D物体渲染在图片上，通过图片显示</em></p><ol><li>专门用一个摄像机渲染3D模型</li><li>将其渲染内容输出到<code>Render Texture</code>上（在Project窗口创建），将摄像机上的<code>Target Texture</code>选为<code>Render Texture</code></li><li>在渲染UI的摄像机下创建<code>RawImage</code>，将<code>Render Texture</code>拖给<code>RawImage</code></li></ol><p>这种方式的好处是不管<code>Canvas</code>的渲染模式是哪种都可以使用。不过只建议只有一个模型的时候使用。</p><h3 id="粒子特效显示在UI之前"><a href="#粒子特效显示在UI之前" class="headerlink" title="粒子特效显示在UI之前"></a>粒子特效显示在UI之前</h3><p>和3D物体一样，不过在摄像机模式下可以改变Particle System粒子组件下的Render参数中的Sorting Layer ID或者Order in Layer，使其始终渲染在其他物体前。</p><h2 id="自动布局组件和适配器"><a href="#自动布局组件和适配器" class="headerlink" title="自动布局组件和适配器"></a>自动布局组件和适配器</h2><p><strong>自动布局组件</strong>可以帮助我们自动设置UI控件的位置和大小等。</p><p>自动布局 &#x3D; 自动布局组件 + 布局元素。其中，<strong>布局元素</strong>是指具有布局属性的对象，主要是指有<code>RectTransform</code>的UI组件。</p><ol><li>水平&#x2F;垂直布局组件（<code>Horizontal Layout Group</code>和<code>Vertical Layout Group</code>）</li></ol><p><strong>水平垂直布局组件</strong>会将子对象并排或者垂直的放在一起。</p><p>参数相关：</p><ul><li>padding：左右上下边缘偏移位置</li><li>Spacing：子对象之间的间距</li><li>ChildAlignment：九宫格对齐方式</li><li>Control Child Size：是否控制子对象的宽高</li><li>Use Child Scale：在设置子对象大小和布局时，是否考虑子对象的缩放</li><li>Child Force Expand：是否强制子对象拓展以填充额外可用空间</li></ul><p>另外，可以给子对象添加一个组件<code>Layout Element</code>布局元素，可以设置子对象的最小（Min）&#x2F;最大（Preferred）宽高</p><ol start="2"><li>网格布局组件（Grid Layout Group）</li></ol><p><strong>网格布局组件</strong>可以将子对象当成一个个的格子设置他们的大小和位置。</p><p>参数相关：</p><ul><li>padding：左右上下边缘偏移位置</li><li>Cell Size：每个格子的大小</li><li>Spacing：格子间隔</li><li>Start Corner：第一个元素所在位置（4个角）</li><li>Start Axis：沿哪个轴放置元素</li><li>Child Alignment：格子对齐方式（9宫格）</li><li>Constraint：行列约束<ul><li>Flexible：灵活模式，根据容器大小自动适应</li><li>Fixed Column Count：固定列数</li><li>Fixed Row Count：固定行数</li></ul></li></ul><ol start="3"><li>内容大小适配器（Content Size Fitter）</li></ol><p><strong>内容大小适配器</strong>可以自动的调整<code>RectTransform</code>的长宽来让组件自动设置大小。一般在<strong>Text</strong>、<strong>ScrollView</strong>上使用，或者配合其他<strong>布局组件</strong>一起使用。</p><p>参数相关：</p><ul><li>Horizontal&#x2F;Vertical Fit：如何控制宽度&#x2F;高度<ul><li>Unconstrained：不根据布局元素伸展</li><li>Min Size：根据最小宽高伸展</li><li>Preferred Size：根据偏好宽度伸展</li></ul></li></ul><ol start="4"><li>宽高比适配器（Aspect Ratio Fitter）</li></ol><p><strong>宽高比适配器</strong>可以让布局元素按照一定比例来调整自己的大小，也可以使布局元素在父对象内部根据父对象的大小进行适配。</p><p>参数相关：</p><ul><li>Aspect Mode：适配模式<ul><li>None：不让矩形适应宽高比</li><li>Width Controls Height：根据宽度自动调整高度</li><li>Height Controls Width：根据高度自动调整宽度</li><li>Fit In Parent：自动调整宽度、高度、位置和锚点。使矩形适应父矩形，同时保持宽高比，会出现“黑边”</li><li>Envelope Parent：自动调整宽度、高度、位置和锚点。使矩形填满父矩形，同时保持宽高比，会出现“裁剪”</li></ul></li><li>Aspect Ratio：宽高比</li></ul><h2 id="CanvasGroup-画布组"><a href="#CanvasGroup-画布组" class="headerlink" title="CanvasGroup 画布组"></a>CanvasGroup 画布组</h2><p><strong>CanvasGroup 画布组</strong>是一个组件，添加到一个父对象后可以帮助我们整体的控制一个面板的淡入淡出、整体禁用。</p><p>参数相关：</p><ul><li>Alpha：整体透明度控制</li><li>Interactable：整体启用禁用设置</li><li>Blocks Raycasts：整体射线检测设置</li><li>Ignore Parent Group：是否忽略父级CanvasGroup的作用</li></ul>]]></content>
    
    
    <summary type="html">来给你的小游戏做一个漂亮的UI画面吧，这篇文章将介绍Unity中最常用的UI系统——UGUI</summary>
    
    
    
    <category term="Unity/UGUI" scheme="http://tymblog.yuzhiboliuhua.cn/categories/Unity-UGUI/"/>
    
    
    <category term="Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
    <category term="#UGUI" scheme="http://tymblog.yuzhiboliuhua.cn/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/eda74239.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/eda74239.html</id>
    <published>2026-01-07T08:42:00.000Z</published>
    <updated>2026-02-14T08:35:43.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门及基础"><a href="#入门及基础" class="headerlink" title="入门及基础"></a>入门及基础</h1><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>先给出一个简单的c#代码结构：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 命名空间：组织代码的逻辑容器（类似文件夹）</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleCSharpStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 类：C#程序的基本单元（所有代码都在类里）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 封装：</span></span><br><span class="line">        <span class="comment">// 3. 私有字段（隐藏内部数据）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 公共属性（暴露可控的访问接口）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125; <span class="comment">// 读数据</span></span><br><span class="line">            <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125; <span class="comment">// 写数据（value是C#关键字，代表传入的值）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _age; &#125;</span><br><span class="line">            <span class="keyword">set</span> </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 封装的核心：添加逻辑约束，保证数据合法</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> &lt;= <span class="number">120</span>)</span><br><span class="line">                    _age = <span class="keyword">value</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    _age = <span class="number">0</span>; <span class="comment">// 非法值默认设为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 类的方法：封装操作数据的逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowInfo</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;姓名：<span class="subst">&#123;_name&#125;</span>，年龄：<span class="subst">&#123;_age&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 入口类（C#程序必须有一个Main方法作为入口）</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 7. 程序入口：Main方法（static + void + Main，固定格式）</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 主逻辑：创建对象、调用属性/方法</span></span><br><span class="line">            <span class="comment">// 1. 创建Person类的实例</span></span><br><span class="line">            Person person = <span class="keyword">new</span> Person();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 通过公共属性赋值（触发封装的约束逻辑）</span></span><br><span class="line">            person.Name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">            person.Age = <span class="number">18</span>; <span class="comment">// 合法值</span></span><br><span class="line">            <span class="comment">// person.Age = 200; // 非法值，会被封装逻辑设为0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 调用方法</span></span><br><span class="line">            person.ShowInfo();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停控制台，防止运行后直接关闭</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n按任意键退出...&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码结构拆解：</p><table><thead><tr><th>结构名称</th><th>作用说明</th></tr></thead><tbody><tr><td>引用命名空间</td><td>引用一个工具包，类似可以看作c++中的头文件</td></tr><tr><td>命名空间</td><td>组织代码的逻辑容器（类似文件夹）</td></tr><tr><td>类</td><td>C#程序的基本单元（所有代码都在类里）</td></tr><tr><td>函数</td><td>封装操作数据的逻辑</td></tr><tr><td>入口类</td><td>用来写Main方法的地方，可以和业务类放在同一个命名空间，也可以单独放，名称任意</td></tr><tr><td>Main方法</td><td>程序的 “起点”，必须是 <code>static void Main(string[] args)</code>，大小写固定</td></tr></tbody></table><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间</strong>是用来<strong>组织和重写代码</strong>、<strong>管理类</strong>的。他就像是一个工具包，类像是一件一件的工具，放在命名空间里方便取用。</p><p>语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以写n个命名空间，可以同名，可以分开写</strong></p><p>不同命名空间中的<strong>相互使用</strong>需要<strong>引用命名空间</strong>或者<strong>指明出处</strong>。</p><ul><li>引用命名空间</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using 命名空间名</span><br></pre></td></tr></table></figure><ul><li>指明出处</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用的命名空间名.使用的类名</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>不同命名空间中允许有同名类</li><li>命名空间可以包裹命名空间</li></ol><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>输入内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure><p>等待输入一行内容，输入回车键后结束输入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>检测是否按键，只要按下任意一个键盘就会直接结束输入。</p><p>输出一句话：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;yes&quot;</span>); <span class="comment">// 自动换行  </span></span><br><span class="line">Console.Write(<span class="string">&quot;NO&quot;</span>); <span class="comment">//不会换行</span></span><br></pre></td></tr></table></figure><h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>以下是一个枚举：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_MonsterType</span><br><span class="line">&#123;</span><br><span class="line">Normal, <span class="comment">// 0</span></span><br><span class="line">Boss, <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举成员<strong>默认的数值从 0 开始，依次递增 1</strong>，也可以自己赋值</p><p>枚举一般在<code>namespace</code>中申明，常见的使用方式是搭配<code>switch-case</code>来表示玩家状态、类型，以下是一个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E_MonsterType monsterType = E_MonsterType.Boss;</span><br><span class="line"><span class="keyword">switch</span>(monsterType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> E_MonsterType.Normal:</span><br><span class="line"><span class="comment">// 处理普通怪物逻辑</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> E_MonsterType.Boss:</span><br><span class="line"><span class="comment">// 处理Boss逻辑</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的类型转换：</p><ol><li><p>枚举 -&gt; <code>int</code>：<code>int i = (int)monsterType;</code><br> <code>int</code> -&gt; 枚举：<code>monsterType = 0;</code></p></li><li><p>枚举 -&gt; 字符串：<code>string str = monsterType.ToString();</code><br> 字符串 -&gt; 枚举：</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：转为的枚举类型</span></span><br><span class="line"><span class="comment">// 参数2：用于转换的对应枚举项的字符串</span></span><br><span class="line">monsterType = (E_monsterType)Enum.Parse(<span class="keyword">typeof</span>(E_monsterType), <span class="string">&quot;other&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>其中<code>Enum</code>是一个类名，直接使用它可以调用里面的方法。而之前遇到的<code>enum</code>是一个关键字，用于声明枚举。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>一维数组</li></ol><ul><li>声明：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>得到长度：<code>array.Length</code></p></li><li><p>遍历数组：</p></li></ul><p>遍历数组有两种方法，一种是<code>for</code>循环遍历，一种是使用语法糖<code>foreach</code>遍历：</p><p>先看<code>for</code>循环遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用<code>foreach</code>遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>foreach</code>是一种语法糖，并不是所有类型都支持用<code>foreach</code>遍历。不支持的类型的唯一本质是<strong>未满足可枚举规范</strong>（未实现 <code>IEnumerable</code>&#x2F;<code>IEnumerable&lt;T&gt;</code> 接口，也无公有 <code>GetEnumerator()</code> 方法）。</p><p><strong>迭代器</strong>就是为任意类型提供被<code>foreach</code>遍历的能力，让遍历变得简单、统一、灵活。</p><ul><li><p>获取、修改、查找元素：与<code>c++</code>一致</p></li><li><p>增加、减少数组中的元素：不能直接增加或者减少，只能搬家</p></li></ul><ol start="2"><li>二维数组：</li></ol><ul><li>声明：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[n, m];</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">3</span>]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><ul><li>得到数组的行和列：<ul><li>得到行：<code>array.GetLength(0);</code></li><li>得到列：<code>array.GetLength(1);</code></li></ul></li></ul><p>其中，传入的参数是维度索引：<code>0</code>对应第一维度，<code>1</code>对应第二维度，<code>2</code>对应第三维度。</p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>除了下述引用类型之外都是值类型。（其中与<code>c++</code>不同的是：<code>float</code>类型后加<code>f</code>，<code>decimal</code>类型后加<code>m</code>）</p><p><strong>相互赋值时会把内容拷贝给对方</strong></p><p>值类型存储在 <em>栈空间</em>：系统分配，小而快。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h5 id="引用类型总览"><a href="#引用类型总览" class="headerlink" title="引用类型总览"></a>引用类型总览</h5><p><strong>创建引用对象的时候都要使用new关键字</strong></p><ul><li><code>string</code></li><li>数组</li><li>类</li><li><code>interface</code></li><li>委托</li></ul><p>引用类型存储在 <em>堆空间</em>：手动申请和释放，大而慢。</p><h5 id="特殊的引用类型string"><a href="#特殊的引用类型string" class="headerlink" title="特殊的引用类型string"></a>特殊的引用类型string</h5><p><code>string</code>非常特殊，它具备值类型的特征：他变我不变。<br>每次对string赋值都会重新开一个空间，会消耗相应的内存。</p><p>因此存在一个<code>string</code>的缺点，就是在不断重复赋值的过程中会不断产生内存垃圾，影响程序性能。</p><h6 id="string相关方法"><a href="#string相关方法" class="headerlink" title="string相关方法"></a>string相关方法</h6><ol><li>获取字符串指定位置</li></ol><p>字符串本质是<code>char[]</code>，因此可以获取字符串的指定位置元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;大鱼飞九草&quot;</span>；</span><br><span class="line">Console.WriteLine(str[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><ol start="2"><li>转为char数组</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>[] chars = str.ToCharArray();</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>字符串拼接</strong></li></ol><ul><li>方式一：用 <code>+</code> 连接字符串 &#x2F; 变量</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;Alice&quot;</span>; </span><br><span class="line"><span class="built_in">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">string</span> message = <span class="string">&quot;我的名字是 &quot;</span> + name + <span class="string">&quot;，年龄是 &quot;</span> + age + <span class="string">&quot; 岁。&quot;</span>; Console.WriteLine(message); </span><br><span class="line"><span class="comment">// 输出：我的名字是 Alice，年龄是 30 岁。</span></span><br></pre></td></tr></table></figure><ul><li>方式二：内插字符串，在字符串前加 <code>$</code>，用 <code>&#123;&#125;</code> 包裹变量 &#x2F; 表达式</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">double</span> score = <span class="number">98.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> result = <span class="string">$&quot;姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>，成绩：<span class="subst">&#123;score&#125;</span>分&quot;</span>;</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line"><span class="comment">// 输出：姓名：小明，年龄：20，成绩：98.5分</span></span><br></pre></td></tr></table></figure><ol start="4"><li>查找</li></ol><ul><li>正向查找字符位置</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;我是大鱼飞九草&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;草&quot;</span>);<span class="comment">//找到了</span></span><br><span class="line">Console.WriteLine(index);<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">index=str.Indexof(<span class="string">&quot;花&quot;</span>);<span class="comment">//没找到</span></span><br><span class="line">Console.WriteLine(index);<span class="comment">// -1</span></span><br></pre></td></tr></table></figure><ul><li>反向查找字符串位置</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;我是大鱼飞九草大鱼飞九草&quot;</span>;</span><br><span class="line"><span class="comment">// 从后往前找，先出现的</span></span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;大鱼飞九草&quot;</span>);</span><br><span class="line"><span class="comment">// 位置是从前往后数的位置</span></span><br><span class="line">Console.WriteLine(index);<span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ol start="5"><li>移除指定位置后的字符</li></ol><ul><li>移除指定位置后所有字符</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;我是大鱼飞九草&quot;</span>;</span><br><span class="line">str = str.Remove(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li>从指定位置移除指定个数字符</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：开始位置</span></span><br><span class="line"><span class="comment">// 参数2：字符个数</span></span><br><span class="line">str = str.Remove(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>替换指定字符串</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;我是大鱼飞九草&quot;</span>;</span><br><span class="line"><span class="comment">// 参数1：原字符串</span></span><br><span class="line"><span class="comment">// 参数2：将要替换的字符串</span></span><br><span class="line">str = str.Replace(<span class="string">&quot;我是大鱼飞九草&quot;</span>,<span class="string">&quot;我是小鸟游六花&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="7"><li>大小写转换</li></ol><ul><li>转大写</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = str.ToUpper();</span><br></pre></td></tr></table></figure><ul><li>转小写</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = str.ToLower();</span><br></pre></td></tr></table></figure><ol start="8"><li>字符串截取</li></ol><ul><li>截取指定位置后的所有字符</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;大鱼飞九草&quot;</span>;</span><br><span class="line">str.Substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>从指定位置截取指定个数字符</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：开始位置</span></span><br><span class="line"><span class="comment">// 参数2：指定个数</span></span><br><span class="line">str = str.Substring(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ol start="9"><li>字符串切割</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;1, 2, 3, 4, 5, 6, 7, 8&quot;</span>;</span><br><span class="line"><span class="comment">// 通过逗号切割</span></span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(strs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h6><p><code>StringBuilder</code>是<code>C#</code>提供的一个人用于处理字符串的公共类。使用它能实现修改字符串而不创建新的对象，需要频繁修改和拼接的字符串可以使用它，可以提升性能。</p><p><strong>注意：使用前需要引用命名空间</strong></p><ol><li>初始化：<code>new</code></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123123123&quot;</span>);<span class="comment">//可以在后边打逗号，设置容量大小</span></span><br><span class="line">Console.WriteLine(str);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code>存在一个容量的问题，每次往里面增加时会自动扩容获得容量，获得容量的方法：<code>str.Capacity</code></p><ol start="2"><li>相关操作</li></ol><ul><li>增</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line">str.Append(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">100</span>, <span class="number">999</span>);</span><br></pre></td></tr></table></figure><ul><li>插</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：插入位置</span></span><br><span class="line"><span class="comment">// 参数2：要插入的字符串</span></span><br><span class="line">str.Insert(<span class="number">0</span>, <span class="string">&quot;小草&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：从哪个位置开始删</span></span><br><span class="line"><span class="comment">// 参数2：删多少个</span></span><br><span class="line">str.Remove(<span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>清空</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.Clear();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>改</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>替换</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：要替换的位置</span></span><br><span class="line"><span class="comment">// 参数2：要改成的字符</span></span><br><span class="line">str.Replace(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;六花&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p><img src="https://tymimg.yuzhiboliuhua.cn/CSharp_Base/Time.png" alt="变量的生命周期"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h3><p>解决在函数内部改变外部传入的内容的问题。</p><p><code>ref</code>和<code>out</code>的使用很简单，在申明参数和引用时在前面加上<code>ref</code>或<code>out</code>关键字即可。</p><p>以下是两个实例：</p><ol><li><code>ref</code>的使用：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">ChangeValueRef(<span class="keyword">ref</span> a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeValueRef</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>out</code>的使用：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeValueOut</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">value</span> = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借此可以看出<code>ref</code>和<code>out</code>的区别：</p><ol><li><code>ref</code>传入的变量必须初始化，<code>out</code>不用</li><li><code>out</code>传入的变量必须在内部赋值，<code>ref</code>不用</li></ol><h3 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h3><ol><li>变长参数</li></ol><ul><li>关键字：<code>params</code></li><li>作用：可以传入<code>n</code>个同类型参数，<code>n</code>可以是<code>0</code></li><li>注意：<ul><li><code>params</code>后面必须是数组，意味着只能是同一类型的可变参数</li><li>变长参数只能有一个</li><li>必须在所有参数最后写变长参数</li></ul></li></ul><p>以下是一个变长参数应用的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params"><span class="built_in">int</span> a, <span class="keyword">params</span> <span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>参数默认值（可选参数）</li></ol><ul><li>作用：可以给参数默认值，使用时可以不传参，不传用默认的，传了用传的</li><li>注意：<ul><li>可选参数可以有多个</li><li>可选参数只能写在所有参数的后面</li></ul></li></ul><p>以下是一个可选参数应用的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 必选 + 可选</span></span><br><span class="line">ShowUserInfo(<span class="string">&quot;张三&quot;</span>， <span class="number">25</span>)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowUserInfo</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age = <span class="number">20</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;姓名：<span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>作用：</p><ol><li>命名一组功能相似的函数，减少函数名的数量，避免命名空间的污染</li><li>提高程序可读性</li></ol><p>特点：<strong>函数名</strong>相同，<strong>参数</strong>数量不同或数量相同，顺序不同</p><p>实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalcSum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数数量不同</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalcSum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量相同，类型不同</span></span><br><span class="line"><span class="comment">// 注意：函数与返回值类型无关，只与参数类型、个数、顺序有关</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CalcSum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">float</span> f</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量相同，顺序不同</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalcSum</span>(<span class="params"><span class="built_in">int</span> b, <span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h2><h3 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h3><p><code>C#</code>中的 <strong>预处理器指令（也叫编译器指令）</strong> 是一组以<code>#</code>开头的特殊语法指令，核心作用是指导<code>C#</code>在<strong>编译</strong>阶段执行特定的预处理逻辑。</p><p><strong>编译器</strong>是一种翻译程序，它用于将<strong>源语言程序</strong>（某种序设计语言写成的，比如<code>C#</code>、<code>C</code>、<code>C++</code>、<code>Java</code>等语言写的程序）翻译为<strong>目标语言程序</strong>（二进制数表示的伪机器代码写的程序）。</p><p>以下是一些常见的预处理器指令：</p><ul><li><code>#define</code>：定义一个符号，类似一个没有值的变量</li><li><code>#undef</code>：取消<code>define</code>定义的符号，让其失效</li></ul><p>以上两者都是写在脚本文件最前面，一般配合<code>if</code>指令使用，或配合特性。</p><ul><li><code>#if</code></li><li><code>#elif</code></li><li><code>#else</code></li><li><code>#endif</code></li></ul><p>这一组指令和<code>if</code>语句规则一样，一般配合<code>#define</code>定义的符号使用，用于告诉编译器进行编译代码的流程控制。</p><p>除此之外，预处理器指令可以通过<strong>逻辑或</strong>和<strong>逻辑与</strong>进行多种符号的组合判断。</p><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> Unity4</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;版本为Unity4&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> Unity2017 &amp;&amp; IOS</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;版本为Unity2017&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;其他版本&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>#warning</code></li><li><code>#error</code></li></ul><p>这两条指令是告诉编译器报警告还是报错误，一般配合<code>#if</code>使用，以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> Unity4</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;版本为Unity4&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> Unity2017 &amp;&amp; IOS</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;版本为Unity2017&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">warning</span> 这个版本不合法</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;其他版本&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">error</span> 这个版本不准执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h3><p>为了使编程时逻辑更加清晰，可以使用折叠代码。他能将包裹的代码折叠起来，避免代码太过凌乱。折叠代码属于<strong>编辑器指令</strong>，是仅由代码编辑器（如 <code>Visual Studio</code>、<code>Rider</code>、<code>VS Code</code> 等）识别和解析的特殊语法指令。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> MyRegion    </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><p><code>MyRegion</code> 为折叠名称，可以自定义名称。</p><p>折叠代码本质上是编辑器提供给我们的预处理指令的工具，只会在编辑时有用。在发布代码后或者执行代码后会被删除。</p><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>为了避免代码报错时造成程序卡死的情况，可以使用异常捕获。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必备部分  </span></span><br><span class="line"><span class="keyword">try</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span>(Exception e)  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//可选部分  </span></span><br><span class="line"><span class="keyword">finally</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将希望进行异常捕获的代码块放入try中，如果try中的代码出错了，会执行catch中的代码，来捕获异常。<br>finally表示，最后执行的代码，不管有没有出错都会执行其中的代码。</p><h3 id="看默认值的方法"><a href="#看默认值的方法" class="headerlink" title="看默认值的方法"></a>看默认值的方法</h3><p><code>Console.WriteLine(defaute(int));</code></p><h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><p>F12进到类型的内部去查看</p><ol><li>是c1ass就是引用</li><li>是struct就是值</li></ol><p>另外，利用<strong>运算符</strong><code>typeof()</code>还可以获得这个类的<code>Type</code>，其中，参数传入<strong>类的名字</strong>。<code>Type</code>是一个抽象基类。</p><h3 id="变量本质及命名"><a href="#变量本质及命名" class="headerlink" title="变量本质及命名"></a>变量本质及命名</h3><ol><li>变量的本质：</li></ol><p>变量的本质是二进制，就是一堆0和1。（原因：数据传输是通过电信号来进行传递的，电信号只有开和关两种，因此这里使用0和1来表示。）</p><ol start="2"><li>变量的命名规范：</li></ol><ul><li><p><strong>驼峰命名法</strong></p><p>  首字母小写，之后的首字母大写。<br>  例如：myName、vsCode、loveYou。</p></li><li><p><strong>帕斯卡命名法</strong></p><p>  所有单词首字母都大写（<em>函数，类</em>）。<br>  例如：MyName、YourName。</p></li></ul><ol start="3"><li>变量 -&gt; 常量：</li></ol><p>在变量类型前面加上const前缀即可表示常量。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ol><li><p>转义字符的写法：<code>\</code> + 特定字符</p></li><li><p>常见的转义字符：</p></li></ol><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\&quot;</code></td><td>双引号（普通字符）</td></tr><tr><td><code>\&#39;</code></td><td>单引号（普通字符）</td></tr><tr><td><code>\\</code></td><td>反斜杠本身</td></tr><tr><td><code>\n</code></td><td>换行符</td></tr><tr><td><code>\t</code></td><td>制表符（Tab 键，4 个空格）</td></tr><tr><td><code>\0</code></td><td>空字符</td></tr></tbody></table><p>化简写法：</p><p>如果你觉得转义字符麻烦，<code>C#</code> 提供了<strong>逐字字符串</strong>（在字符串前加 <code>@</code>），可以直接写特殊字符，无需转义：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> path = <span class="string">@&quot;C:\Code\Demo\test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐字字符串里的双引号，用两个&quot;&quot;表示一个&quot; </span></span><br><span class="line"><span class="built_in">string</span> quote = <span class="string">@&quot;小明说：&quot;&quot;我在学C#的转义字符&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>核心部分笔记参见<a href="https://tymblog.yuzhiboliuhua.cn/posts/eda74239.html">C#之面向对象 | MeiMeiBlog</a></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="简单的数据结构类"><a href="#简单的数据结构类" class="headerlink" title="简单的数据结构类"></a>简单的数据结构类</h2><p><strong>数据结构</strong>主要研究<strong>数据</strong>如何在计算机中<strong>组织</strong>和<strong>存储</strong>，以及对这些数据进行<strong>操作</strong>。</p><p>主要包含以下三大板块：</p><ul><li><p>线性结构</p><ul><li>数组（<code>Array</code>）</li><li>链表（<code>Linked List</code>）</li><li>栈（<code>Stack</code>）</li><li>队列（<code>Queue</code>）</li></ul></li><li><p>非线性结构</p><ul><li>树（<code>Tree</code>）</li><li>图（<code>Graph</code>）</li></ul></li><li><p>集合与映射</p><ul><li>哈希表（<code>Hash Table</code>）</li><li>字典（<code>Dictionary</code>）</li></ul></li></ul><h3 id="ArrayList-动态数组"><a href="#ArrayList-动态数组" class="headerlink" title="ArrayList 动态数组"></a>ArrayList 动态数组</h3><p><strong><code>Array</code>、<code>ArrayList</code>和<code>List&lt;&gt;</code>的区别与联系：</strong></p><table><thead><tr><th>类型</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><code>Array</code></td><td>数组</td><td>最基础的原生数组类型，如<code>int[]</code>、<code>string[]</code>。固定长度，强类型（声明时指定元素类型）</td></tr><tr><td><code>ArrayList</code></td><td>动态数组</td><td>基于<code>Array</code>封装的可变长度的数组。弱类型（可存储各种类型的元素）</td></tr><tr><td><code>List&lt;&gt;</code></td><td>泛型列表</td><td>完美结合<code>Array</code>和<code>ArrayList</code>（可变长度 + 强类型）</td></tr></tbody></table><p><code>ArrayList</code>是一个<code>C#</code>为我们封装好的类，他的本质是<code>object[]</code></p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><p>增加有两种方式，分别是<strong>一个一个的增加</strong>，也可以<strong>按范围增加</strong>。</p><p>一个一个的增加：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.Add(<span class="number">1</span>); <span class="comment">// 增加一个int型</span></span><br><span class="line">array.Add(<span class="keyword">new</span> <span class="built_in">object</span>()); <span class="comment">// 增加一个类</span></span><br></pre></td></tr></table></figure><p>按范围增加：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList2.Add(<span class="number">123</span>);</span><br><span class="line">arrayList.AddRange(arrayList2);</span><br></pre></td></tr></table></figure><ul><li>插</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：要插入的位置</span></span><br><span class="line"><span class="comment">// 参数2：要插入的元素</span></span><br><span class="line">array.Insert(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值删除 从头找</span></span><br><span class="line">arrayList.Remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 按位置删除</span></span><br><span class="line">arrayList.RemoveAt(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">arrayList.Clear();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>得到指定位置的元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayList[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>查看元素是否存在：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayList.Contains(<span class="string">&quot;1234&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正向查找元素位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：要查找的元素</span></span><br><span class="line"><span class="comment">// 找到：返回值 是位置</span></span><br><span class="line"><span class="comment">// 找不到：返回值 是-1</span></span><br><span class="line"><span class="built_in">int</span> index = arrayList.IndexOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>反向查找元素位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：从头开始的索引数</span></span><br><span class="line">index = arrayList.LastIndexOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>改</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayList[<span class="number">0</span>] = <span class="string">&quot;999&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>遍历</p><ul><li><p>得到长度：<code>arrayList.Count</code></p></li><li><p>得到容量：<code>arrayList.Capacity</code>，可以避免产生过多垃圾</p></li></ul></li></ul><p>方法1：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrayList.Count; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> arrayList)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h3><p><code>Stack</code>(栈)是一个<code>C#</code>为我们封装好的<strong>类</strong>，它的本质也是<code>object[]</code>。他的特殊之处在于封装了特殊的存储规则：<strong>先进后出</strong>。</p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能一个一个的压入</span></span><br><span class="line">stack.Push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>取</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = stack.Pop();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>栈无法查看指定位置的元素，只能查看栈顶的内容。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = stack.Peek();</span><br></pre></td></tr></table></figure><p>还可以看元素是否存在于栈中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stack.Contains(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改（清空）</li></ul><p>栈无法改变其中的元素只能压（存）和弹（取），实在要改只有清空</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure><ul><li><p>遍历</p><ul><li>得到长度：<code>stack.Count</code></li></ul></li></ul><p>因为栈没有索引器，故只能用<code>foreach</code>遍历，得到的顺序是从栈顶到栈底。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，也可以将栈转为<code>object[]</code>遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>[] array = stack.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环弹栈</li></ul><p>只要栈中存在元素，便不断弹出。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">object</span> o = stack.Pop();</span><br><span class="line">Console.WriteLine(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h3><p><code>Queue</code>是一个<code>c#</code>为我们封装好的<strong>类</strong>，它的本质也是<code>object[]</code>数组。只是封装了特殊的存储规则：<strong>先进先出</strong>。</p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能一个一个的入队</span></span><br><span class="line">queue.Enqueue(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>取</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> v = queue.Dequeue();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>查看队列头部元素（不会移除）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = queue.Peek();</span><br></pre></td></tr></table></figure><p>查看元素是否存在于队列中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(queue.Contains(<span class="number">1.4f</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改（清空）</li></ul><p>队列无法改变其中的元素只能进出队列，实在要改只有清空</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure><ul><li><p>遍历</p><ul><li>得到长度：<code>queue.Count;</code></li></ul></li></ul><p>用<code>foreach</code>遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> queue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将队列转为<code>object[]</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>[] array = queue.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环出列</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">object</span> o = queue.Dequeue();</span><br><span class="line">Console.WriteLine(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable-哈希表"><a href="#Hashtable-哈希表" class="headerlink" title="Hashtable 哈希表"></a>Hashtable 哈希表</h3><p><code>Hashtable</code>是基于键的哈希代码组织起来的<strong>键值对</strong>。它的主要作用是提高数据查询的效率，使用键来访问集合中的元素。</p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> hashtable();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：键 object类型</span></span><br><span class="line"><span class="comment">// 参数2：值 object类型</span></span><br><span class="line">hashtable.Add(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：不能出现相同键</strong></p><ul><li>删</li></ul><p>只能通过<strong>键</strong>去删除，删除不存在的键没反应。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashtable.Remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>或者直接清空：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashtable.Clear();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>通过键查看值，如果找不到会返回<code>null</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(hashtable[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>查看是否存在，可以通过键查看、也可以通过值查看，我们先来看通过<strong>键</strong>查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">if</span>(hashtable.Contains(<span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">if</span>(hashtable.ContainsKey(<span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过<strong>值</strong>查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hashtable.ContainsValue(<span class="number">12</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改</li></ul><p>只能改键对应的值内容，无法修改键。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">1</span>] = <span class="number">100.5f</span>;</span><br></pre></td></tr></table></figure><ul><li><p>遍历</p><ul><li>得到键值对对数：<code>hashtable.Count;</code></li></ul></li></ul><p>遍历所有键：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> hashtable.Keys)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 得到键</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;键：&quot;</span> + item);</span><br><span class="line"><span class="comment">// 已知键，求值</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;值：&quot;</span> + hashtable[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> hashtable.Values)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;值：&quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键值对一起遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(DictionaryEntry item <span class="keyword">in</span> hashtable)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;键：&quot;</span> + item.Key + <span class="string">&quot;值：&quot;</span> + item.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器遍历法：</p><p>迭代器就是为任意类型提供被<code>foreach</code>遍历的能力，让遍历变得简单、统一、灵活。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();</span><br><span class="line"><span class="comment">// 游标</span></span><br><span class="line"><span class="built_in">bool</span> falg = myEnumerator.Movenext(); </span><br><span class="line"><span class="keyword">while</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;键：&quot;</span> + myEnumerator.Key + <span class="string">&quot;值：&quot;</span> + myEnumerator.Value);</span><br><span class="line">flag = myEnumerator.MoveNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型及常用泛型数据结构类"><a href="#泛型及常用泛型数据结构类" class="headerlink" title="泛型及常用泛型数据结构类"></a>泛型及常用泛型数据结构类</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ol><li>用泛型可以实现<strong>复用代码</strong>的目的，改变类型不过其中的逻辑一样</li><li>泛型相当于类型占位符</li><li><strong>定义</strong>类或方法时使用<strong>替代符</strong>代表变量类型；当真正<strong>使用</strong>类或者方法时再<strong>具体指定类型</strong></li></ol><ul><li>泛型的分类</li></ul><p>泛型可以分为<strong>泛型类</strong>、<strong>泛型接口</strong>、和<strong>泛型函数</strong>。</p><p><em>泛型类</em></p><p>申明语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&lt;泛型占位字母&gt;</span><br></pre></td></tr></table></figure><p>以下是一个具体的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 对象1：</span></span><br><span class="line">TestClass&lt;<span class="built_in">int</span>&gt; t = <span class="keyword">new</span> TestClss&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t.<span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对象2：</span></span><br><span class="line">TestClass&lt;<span class="built_in">string</span>&gt; t = <span class="keyword">new</span> TestClss&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">t.<span class="keyword">value</span> = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>泛型接口</em></p><p>申明语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 接口名&lt;泛型占位字母&gt;</span><br></pre></td></tr></table></figure><p>以下是一个具体的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">TestInterface</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">T Value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>;</span><br><span class="line"><span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">TestInterface</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line"><span class="keyword">set</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>泛型函数</em></p><p>申明语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名&lt;泛型占位字母&gt;(参数列表)</span><br></pre></td></tr></table></figure><p><strong>注意：泛型占位字母可以有多个，用逗号分开</strong></p><ul><li>普通类的泛型方法</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 申明：泛型占位符作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Test2 tt = <span class="keyword">new</span> Test2();</span><br><span class="line">tt.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123123&quot;</span>); <span class="comment">// 打印结果：123123</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，泛型占位符还可作为返回值。</p><ul><li>泛型类的泛型方法</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申明 泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun1</span>(<span class="params">T t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 具体逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>TestFun1(T t)</code>这个函数不是泛型方法。因为<code>T</code>是泛型类申明的时候就指定的。再使用这个函数的时候我们就不能再去动态的变化了。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>泛型约束</strong>可以让泛型的类型有一定的限制。要想<code>new</code>一个<code>T</code>，必须加约束，因为无法得知是否可以访问（<code>private</code>）</p><ol><li><p>关键字：<code>where</code></p></li><li><p>分类：</p></li></ol><table><thead><tr><th>约束类型</th><th>表现方式</th></tr></thead><tbody><tr><td><strong>值类型</strong></td><td><code>where 泛型字母:struct</code></td></tr><tr><td><strong>引用类型</strong></td><td><code>where 泛型字母:class</code></td></tr><tr><td>存在无参非抽象公共构造函数</td><td><code>where 泛型字母:new()</code></td></tr><tr><td>某个类本身或者其派生类</td><td><code>where 泛型字母:类名</code></td></tr><tr><td>某个接口的派生类型</td><td><code>where 泛型字母:接口名</code></td></tr><tr><td>另一个泛型类型本身或者派生类型</td><td><code>where 泛型字母:另一个泛型字母</code></td></tr></tbody></table><p>注意：多个约束可以组合使用，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="keyword">class</span>, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也存在多个泛型有不同约束的情况，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="keyword">class</span>, <span class="keyword">where</span> <span class="title">K</span>:<span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用泛型数据结构类"><a href="#常用泛型数据结构类" class="headerlink" title="常用泛型数据结构类"></a>常用泛型数据结构类</h3><h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List&lt;&gt; 列表"></a>List&lt;&gt; 列表</h4><p><code>List&lt;&gt;</code>是一个<code>c#</code>为我们封装好的<strong>类</strong>，它的本质是一个可变类型的<strong>泛型数组</strong>。</p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span>.System.Collections.Genertic;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><p>单个增：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>批量增：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.AddRange(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure><ul><li>插</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：插入位置</span></span><br><span class="line"><span class="comment">// 参数2：插入的值</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="number">999</span>);</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><p>移除指定元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>移除指定位置的元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.RemoveAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>清空：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Clear();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>得到指定位置的元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(list[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>查看元素是否存在：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( list.Contains(<span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;存在元素1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正向查找元素位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 返回位置</span></span><br><span class="line"><span class="comment">// 找不到 返回-1</span></span><br><span class="line"><span class="built_in">int</span> index = list.IndexOf(<span class="number">5</span>);</span><br><span class="line">Console.WriteLine(index);</span><br></pre></td></tr></table></figure><p>反向查找元素位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 返回位置</span></span><br><span class="line"><span class="comment">// 找不到 返回-1</span></span><br><span class="line">index =<span class="number">1</span>ist.LastIndexOf(<span class="number">2</span>);</span><br><span class="line">Console.WriteLine(index);</span><br></pre></td></tr></table></figure><ul><li>改</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>ist[<span class="number">0</span>]=<span class="number">99</span>;</span><br></pre></td></tr></table></figure><ul><li><p>遍历</p><ul><li>得到长度：<code>list.Count</code></li><li>得到容量：<code>list.Capacity</code></li></ul></li></ul><p>用<code>for</code>循环遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i ++)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>foreach</code>遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>List</code>排序</li></ul><p><em><code>List</code>自带排序方法：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统自带的变量（int、double）排序方法，默认升序</span></span><br><span class="line">list.Sort();</span><br></pre></td></tr></table></figure><p><em>自定义类排序：</em></p><p>自定义类排序的重点是将类继承<code>IComparable&lt;T&gt;</code>接口，<code>IComparable&lt;T&gt;</code> 是<strong>泛型比较接口</strong>，核心作用是为自定义类定义<strong>排序规则</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Item</span> : <span class="title">IComparable</span>&lt;<span class="title">Item</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">int</span> money</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.money = money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承接口实现的比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Item other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.money &gt; other.money)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>CompareTo()</code>这个函数有<strong>特定的规则</strong>，这是行业决定的，不能自己修改：</p><table><thead><tr><th>返回值</th><th>含义</th><th>排序结果</th></tr></thead><tbody><tr><td>负数（<code>&lt;0</code>）</td><td>当前对象 &lt; 待比较对象（<code>this &lt; other</code>）</td><td>当前对象排在<strong>前面</strong></td></tr><tr><td><code>0</code></td><td>当前对象 &#x3D;&#x3D; 待比较对象（<code>this == other</code>）</td><td>两个对象<strong>排序位置相同</strong></td></tr><tr><td>正数（<code>&gt; 0</code>）</td><td>当前对象 &gt; 待比较对象（<code>this &gt; other</code>）</td><td>当前对象排在<strong>后面</strong></td></tr></tbody></table><ul><li><code>Lambda</code>表达式 + 三目运算符</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shopItems.Sort((a, b) =&gt; &#123;<span class="keyword">return</span> a.id &gt; b.id ? <span class="number">1</span> : <span class="number">-1</span>;&#125;);</span><br></pre></td></tr></table></figure><h4 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary&lt;&gt; 字典"></a>Dictionary&lt;&gt; 字典</h4><p>可以将<code>Dictionary&lt;&gt;</code>理解为拥有<strong>泛型</strong>的<code>Hashtable</code>，它也是基于键的哈希代码组织起来的<strong>键&#x2F;值对</strong>。键值对类型从<code>Hashtable</code>的<code>object</code>变为了可以自己制定的泛型。</p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary.Add(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意：键名不能重复</p><ul><li>删</li></ul><p>只能通过键去删除，删除不存在键没反应。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>也可以直接清空。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary.Clear();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>通过键查看值（查不到会直接报错）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(dictionary[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>查看是否存在有两种方法，根据键检测、或者根据值检测。</p><p>先来看根据键检测：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dictionary.ContainsKey(<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;存在键为1的键值对&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看根据值检测：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dictionary.ContainsValue(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">Conso1e.WriteLine(<span class="string">&quot;存在值为123的键值对);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>改</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;555&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>遍历</p><ul><li>得到键值对对数：<code>dictionary.Count</code></li></ul></li></ul><p>遍历所有键：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> dictionary.Keys)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打印所有键</span></span><br><span class="line">Console.WriteLine(item);</span><br><span class="line"><span class="comment">// 根据键得到值</span></span><br><span class="line">Console.WriteLine(dictionary[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> item <span class="keyword">in</span> dictionary.Values)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键值对一起遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; item <span class="keyword">in</span> dictionary)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;键：&quot;</span> + item.Key + <span class="string">&quot;值：&quot;</span> + item.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedList-双向链表"><a href="#LinkedList-双向链表" class="headerlink" title="LinkedList&lt;&gt; 双向链表"></a>LinkedList&lt;&gt; 双向链表</h4><p><code>LinkedList</code>是一个<code>c#</code>为我们封装好的<strong>类</strong>, 它的本质是一个可变类型的泛型<strong>双向链表</strong>。</p><ol><li>申明</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedlist = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>增删查改</li></ol><ul><li>增</li></ul><p>在链表尾部添加元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linkedList.AddLast(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>在链表头部添加元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linkedList.AddFirst(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>在某一个节点之后添加一个节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要指定节点先得得到一个节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; n = linkedList.Find(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 参数1：在哪个节点后添加一个结点</span></span><br><span class="line"><span class="comment">// 参数2：要添加的结点的值</span></span><br><span class="line">linkedList.AddAfter(n,<span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>在某一个节点之前添加一个节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要指定节点先得得到一个节点</span></span><br><span class="line">linkedList.AddBefore(n,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><p>移除头节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linkedList.RemoveFirst();</span><br></pre></td></tr></table></figure><p>移除尾节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linkedList.RemoveLast();</span><br></pre></td></tr></table></figure><p>移除指定节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法通过位置直接移除,只能通过值移除</span></span><br><span class="line">linkedList.Remove(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>清空：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linkedList.Clear();</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><p>头节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First;</span><br></pre></td></tr></table></figure><p>尾节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last;</span><br></pre></td></tr></table></figure><p>找到指定值的节点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法直接通过下标获取中间元素</span></span><br><span class="line"><span class="comment">//只有遍历查找指定位置元素，找不到返回空</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt;node = linkedList.Find(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>判断是否存在：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(linkedList.Contains(<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;链表中存在1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要先得再改得到节点，再改变其中的值</span></span><br><span class="line">linkedList.First.Value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><p><code>foreach</code>遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> linkedList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 自动得到里面的value</span></span><br><span class="line">Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过节点遍历有两种方法，<em>从头到尾</em>和<em>从尾到头</em>，下面先来看从头到尾遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; nowNode = linkedList.First;</span><br><span class="line"><span class="keyword">while</span>(nowNode != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(nowNode.Value);</span><br><span class="line">nowNode = nowNode.Next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看从尾到头：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; nowNode = linkedList.Last;</span><br><span class="line"><span class="keyword">while</span>(nowNode != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(nowNode.Value);</span><br><span class="line">nowNode = nowNode.Previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h4><ol><li>申明：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line">Queue&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用：和<strong>简单数据结构类</strong>中的<code>Stack</code>、<code>Queue</code>一样</li></ol><h2 id="委托、事件与Lambda表达式"><a href="#委托、事件与Lambda表达式" class="headerlink" title="委托、事件与Lambda表达式"></a>委托、事件与Lambda表达式</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p><strong>委托</strong>是<strong>函数的容器</strong>，用来存储、传递函数，可以理解为像指针一样，他装函数的意思是存储了<strong>函数的引用</strong>，因此调用委托时就可以调用函数本身。他能让你的程序<strong>不再死等（异步回调）</strong>，还能<strong>一键通知所有人（多播）</strong>。本质是一个<strong>类</strong>，用来定义函数的类型（返回值和参数的类型）。不同的函数（方法）必须对应和各自”格式”一致的委托。</p><ol><li><p>关键字：<code>delegate</code></p></li><li><p>语法：</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="built_in">delegate</span> 返回值 委托名(参数列表);</span><br></pre></td></tr></table></figure><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 委托一般写在 namespace 中</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Lesson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义自定义委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun</span>()</span>; </span><br><span class="line"></span><br><span class="line">Class Program</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line">MyFun f = <span class="keyword">new</span> MyFun(Fun);</span><br><span class="line"><span class="comment">// 调用委托</span></span><br><span class="line">f.Invoke();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line">MyFun f2 = Fun;</span><br><span class="line"><span class="comment">// 调用委托</span></span><br><span class="line">f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须和委托类型一致（这里是无参无返回值类型）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>访问修饰默认不写为<code>public</code>，一般使用<code>public</code></li><li>委托不能重名</li></ol><p>除了这种自定义委托外，还有<strong>系统定义委托</strong>，其实我们更常用系统定义好的委托：</p><p>要用系统定义委托，需要引用以下<strong>命名空间</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br></pre></td></tr></table></figure><ul><li>无参无返回</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action action = Fun;</span><br></pre></td></tr></table></figure><ul><li>可以指定返回值类型的 泛型委托</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;T&gt; funcT = Fun2; </span><br></pre></td></tr></table></figure><ul><li>可以传<code>n(1~16)</code>个参数的 泛型委托</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;T, K&gt; action = Fun3; </span><br></pre></td></tr></table></figure><ul><li>可以传<code>n(1~16)</code>个参数且有<code>1</code>个返回值的 泛型委托</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面写参数</span></span><br><span class="line"><span class="comment">// 后面写返回值</span></span><br><span class="line">Func&lt;T, K&gt; func2 = Fun4;</span><br></pre></td></tr></table></figure><p>委托可以作为<em>类的成员</em>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> MyFun fun;</span><br><span class="line"><span class="keyword">public</span> MyFun2 fun2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以作为<em>函数的参数</em>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun fun, MyFun2 fun2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 先处理一些别的逻辑，再处理委托里的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，委托变量可以存储多个函数。这样就可以实现同时通知多个函数调用的功能，这种委托叫<strong>多播委托</strong>。</p><p>多播委托的一些操作：</p><ul><li>增加函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyFun ff = Fun;</span><br><span class="line">ff += Fun;</span><br></pre></td></tr></table></figure><ul><li>移除函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多减不会报错 无非就是不处理</span></span><br><span class="line">ff -= Fun; </span><br></pre></td></tr></table></figure><ul><li>清空委托</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ff = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>事件</strong>是基于委托的存在，事件是委托的<strong>安全包裹</strong>，防止外部随意<strong>置空、调用</strong>委托。让委托的使用更具有安全性。事件是一种<strong>特殊的变量类型</strong>。</p><ol><li><p>关键字：<code>event</code></p></li><li><p>语法：</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 事件名;</span><br></pre></td></tr></table></figure><p><strong>事件的使用和委托一模一样</strong>。</p><p>事件不同于委托的是：它只能作为<strong>成员</strong>在于类、接口以及结构体中。</p><p><em>区别1</em>：委托可以在外部赋值（如<code>t.myFun = null</code>），而事件不行，但可以加减函数（如：<code>t.myEvent += Fun</code>）。</p><p><em>区别2</em>：委托可以在外部调用（如：<code>t.myFun()</code>），而事件不行。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p><strong>匿名函数</strong>就是没有名字的函数，它主要是配合<strong>委托</strong>和<strong>事件</strong>进行使用，脱离委托和事件是不会使用匿名函数的。</p><ol><li>匿名函数语法</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span>(参数列表)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下是几个<code>Unity</code>封装好的<strong>委托</strong>与<strong>匿名函数</strong>的使用：</p><ul><li>无参无返回值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明Action委托</span></span><br><span class="line">Action a = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用委托</span></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><ul><li>有参</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明Action&lt;,&gt;委托</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> a, <span class="built_in">string</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用委托</span></span><br><span class="line">b(<span class="number">100</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>有返回值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明Func&lt;&gt;委托</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; c = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用委托</span></span><br><span class="line">c();</span><br></pre></td></tr></table></figure><p>匿名函数的作用是使代码更加简洁，不过他也有缺点，因为不知道名字，将匿名函数添加到委托或事件容器后不能单独移除。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p><strong><code>Lambda</code>表达式</strong>可以被理解为匿名函数的简写，除了写法不同外，使用上和匿名函数一模一样，都是和委托或者事件配合使用的。</p><ol><li>Lambda表达式语法</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用就是和委托类型保持一致，配合使用就可以。</p><ol start="2"><li>闭包</li></ol><p><strong>闭包</strong>是指<strong>内层的函数</strong>可以引用包含在<strong>它外层的函数的变量</strong>，即使外层函数的执行已经终止。</p><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部函数（构造函数）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 内部函数</span></span><br><span class="line">action = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里形成了闭包</span></span><br><span class="line"><span class="comment">// 因为当构造函数执行完毕时，其中申明的临时变量value的生命周期被改变了</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变"></a>协变与逆变</h2><p><strong>协变和逆变</strong>是<code>C#</code>为<strong>泛型委托、接口</strong>设计的类型转换规则，核心目的是使泛型类型的赋值更灵活。</p><p><strong>协变</strong>，用<code>out</code>关键字标记。允许<strong>子类</strong>泛型类型赋值给<strong>父类</strong>泛型类型（如<code>Func&lt;Dog&gt;</code> -&gt; <code>Func&lt;Animal&gt;</code>）。</p><p><strong>逆变</strong>，用<code>in</code>关键字标记。允许<strong>父类</strong>泛型类型赋值给<strong>子类</strong>泛型类型（如<code>Func&lt;Animal&gt;</code> -&gt; <code>Func&lt;Dog&gt;</code>）。</p><p>其中，<code>out</code>和<code>in</code>都是用于在泛型中<strong>修饰泛型字母</strong>的。</p><h3 id="返回值和参数"><a href="#返回值和参数" class="headerlink" title="返回值和参数"></a>返回值和参数</h3><ul><li>用<code>out</code>修饰的泛型只能作为返回值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">Testout</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><ul><li>用<code>in</code>修饰的泛型只能作为参数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="结合里氏替换原则理解"><a href="#结合里氏替换原则理解" class="headerlink" title="结合里氏替换原则理解"></a>结合里氏替换原则理解</h3><ul><li><p>协变：和谐的变化，自然的变化。因为里氏替换原则父类可以装子类，所以子类变父类。比如<code>string</code>变成<code>object</code>感受是和谐的。</p></li><li><p>逆变：逆常规的变化，不正常的变化。因为里氏替换原则父类可以装子类但是子类不能装父类，所以父类变子类。比如<code>object</code>变成<code>string</code>感受是不和谐的。</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>进程</strong>就是指<strong>一个应用程序</strong>。进程之间相互独立运行，互不干扰；也可以相互访问、操作。</p><p><strong>线程</strong>是指操作系统能够进行运算调度的<strong>最小单位</strong>，它被包含在进程之中，是<strong>进程中的实际运作单位</strong>，<code>Main</code>函数就是主线程，我们目前都在主线程中写程序。可以简单理解为代码从上到下运行的一条“管道”。</p><p>而<strong>多线程</strong>就是可以同时运行代码的多条“管道”。</p><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><p>想用线程，需要引用命名空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br></pre></td></tr></table></figure><ul><li>申明一个新的线程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadLogic);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 新开线程 执行的代码逻辑 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：线程执行的代码 需要封装到一个函数中</strong></p><ul><li>启动线程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Start();</span><br></pre></td></tr></table></figure><ul><li>设置为后台线程</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>设置为后台线程的原因是如果不设置为后台线程，可能导致进程无法正常关闭。</p><ul><li>关闭释放一个线程</li></ul><p><em>情况1</em> 不是死循环 <code>t = null;</code></p><p><em>情况2</em> 是死循环</p><p>有两种方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：死循环中bool标识</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> isRunning = ture;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想停下来到时候在主线程置为 false 就可以停止</span></span><br><span class="line">isRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(isRunning)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：通过线程提供的方法（在.Net core版本中无法停止 会报错）</span></span><br><span class="line">t.Abort();</span><br><span class="line">t = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>线程休眠</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是毫秒数 1s = 1000ms</span></span><br><span class="line"><span class="comment">// 在哪个线程中执行就是休眠哪个线程</span></span><br><span class="line">Thread.Sleep(<span class="number">1000</span>); </span><br></pre></td></tr></table></figure><p>另外，多个线程是共享内存的。所以要注意当多线程同时操作同一片内存区域时，可能会出问题。</p><p> <strong>可以通过加锁（lock）的形式避免问题</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock里面必须填引用类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">object</span> obj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">str[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">lock</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 要处理的同一片区域</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他地方也有要上锁的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设先进入这个语句块 开始执行lock语句块内容，此时上锁，Main函数中无法执行</span></span><br><span class="line"><span class="comment">// 等待处理完回到Main函数继续执行</span></span><br><span class="line"><span class="keyword">lock</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 要处理的同一片区域</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程的意义</strong>是处理一些复杂耗时的逻辑，比如寻路、网络通信等问题。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射的定义"><a href="#反射的定义" class="headerlink" title="反射的定义"></a>反射的定义</h3><p><strong>反射</strong>是指一个运行的程序查看<strong>其它程序集</strong>或者<strong>自身元数据</strong> 的行为。</p><p>其中，<strong>程序集</strong>是经由编译器编译得到的，供进一步编译执行的那个中间产物；在<code>WINDOWS</code>系统中，它一般表现为后缀为<code>.dll</code>(库文件)或者是<code>.exe</code>(可执行文件)的格式。<strong>元数据</strong>是用来描述数据的数据，<em>程序中的类</em>，<em>类中的函数</em>、<em>变量</em>等等信息就是程序的元数据；有关程序以及类型的数据被称为元数据，它们保存在程序集中。这个概念不仅仅用于程序上，在别的领域也有元数据。</p><ol><li>运用反射的链接：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (命令行链接) / gameobject.getcomponent&lt;类型&gt;(方法链接其他程序集)</span><br></pre></td></tr></table></figure><ol start="2"><li>语法相关：见后续分节</li></ol><h3 id="Type-信息类"><a href="#Type-信息类" class="headerlink" title="Type 信息类"></a>Type 信息类</h3><p><code>Type</code>是<strong>类的信息类</strong>，它是反射功能的基础，是访问元数据的主要方式，使用<code>Type</code>的成员获取有关类型申明的信息。</p><ul><li>获取<code>Type</code></li></ul><p><em>方法1</em> 万物之父<code>object</code>中的<code>GetType()</code>方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type = a.GetType();</span><br><span class="line">Console.WriteLine(type); <span class="comment">// 打印出的是类名所在的命名空间</span></span><br></pre></td></tr></table></figure><p><em>方法2</em> 通过<code>typeof</code>关键字传入类名获得</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type2 = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br></pre></td></tr></table></figure><p><em>方法3</em> 通过类的名字获得</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type3 = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中，方法三中的<code>Type</code>是<code>C#</code>里默认的工具。</p><p><strong>注意：类名必须包含命名空间</strong></p><p>获取<code>Type</code>后便可以获得类的各种信息：</p><p>需要引用命名空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br></pre></td></tr></table></figure><ul><li>程序集信息</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(type.Assembly);</span><br></pre></td></tr></table></figure><ul><li>所有公共成员</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemberInfo[] infos = type.GetMembers();</span><br></pre></td></tr></table></figure><ul><li>类中的构造函数</li></ul><p>可以获取所有的构造函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = type.GetConstructors();</span><br></pre></td></tr></table></figure><p>也可以获取其中一个构造函数并执行：</p><p><strong>得构造函数</strong>传入<code>Type[]</code>，数组中内容按顺序是参数类型；<br><strong>执行构造函数</strong>传入<code>object[]</code>，表示按顺序传入的参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.得到无参构造</span></span><br><span class="line"><span class="comment">// 因为是无参构造，所以传入一个长度为0的数组表示</span></span><br><span class="line">ConstructorInfo info = type.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 执行无参构造，因为没有参数，所以传入null</span></span><br><span class="line">Test obj = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.得到有参构造</span></span><br><span class="line">ConstructorInfo info2 = type.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line">obj = info2.Invoke(<span class="keyword">new</span> objct[] &#123; <span class="number">2</span> &#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure><ul><li>公共成员变量</li></ul><p>得到所有成员变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = type.GetFields();</span><br></pre></td></tr></table></figure><p>得到指定名称的公共成员变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：要得到的那个成员变量名</span></span><br><span class="line">FieldInfo infoJ = type.GetFiled(<span class="string">&quot;j&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过反射获取和设置对象的值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="comment">// 参数：其他程序集中类的实例</span></span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="comment">// 参数1：要设置的对象</span></span><br><span class="line"><span class="comment">// 参数2：要设置的值</span></span><br><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><ul><li>公共成员方法</li></ul><p>得到所有方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] methods = strType.GetMethods();</span><br></pre></td></tr></table></figure><p>得到并调用指定名称的方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到指定方法</span></span><br><span class="line"><span class="comment">// 参数1：方法名</span></span><br><span class="line"><span class="comment">// 参数2（可选）：Type数组，指定方法参数类型（int, int），用于区分重载</span></span><br><span class="line">MethodInfo subStr = strType.GetMethod(<span class="string">&quot;Substring&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="comment">// 参数1：执行方法的实例，如果是静态方法传null</span></span><br><span class="line"><span class="comment">// 参数2：object数组，按顺序传入方法的实际参数（7, 5）</span></span><br><span class="line"><span class="built_in">object</span> res = subStr.Invoke(str, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123;<span class="number">7</span>, <span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li>泛型类型</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type fieldType;</span><br><span class="line">fieldType.GetGenericArguments()[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="Assembly-加载其它程序集"><a href="#Assembly-加载其它程序集" class="headerlink" title="Assembly 加载其它程序集"></a>Assembly 加载其它程序集</h3><p><code>Assembly</code>主要用来<strong>加载其它程序集</strong>，加载后才能用<code>Type</code>来使用其它程序集中的信息。</p><p>接下来介绍三种加载程序集的函数：</p><ol><li>加载<strong>同一文件</strong>下的其他程序集：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>加载<strong>不在同一文件</strong>下的其他程序集：</li></ol><p><em>方法1</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件名称或路径&quot;</span>);</span><br></pre></td></tr></table></figure><p><em>方法2</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面是一个综合运用的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先加载一个指定程序集</span></span><br><span class="line">Assembly assembly = Assembly.LoadFrom(<span class="string">@&quot;包含程序集清单的文件名称或路径&quot;</span>);</span><br><span class="line"><span class="comment">// 2.再加载程序集中的一个类对象</span></span><br><span class="line">Type icon = assembly.GetType(<span class="string">&quot;Lesson1.Icon&quot;</span>);</span><br><span class="line"><span class="comment">// 得到这个类对象中的所有成员信息</span></span><br><span class="line">MemberInfo[] members = icon.GetMembers();</span><br></pre></td></tr></table></figure><h3 id="Activator-快速实例化对象"><a href="#Activator-快速实例化对象" class="headerlink" title="Activator 快速实例化对象"></a>Activator 快速实例化对象</h3><p><code>Activator</code>可以将<code>Type</code>对象<strong>快速实例化对象</strong>。</p><ol><li>无参构造</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type testType = typeod(Test);</span><br><span class="line">Test testObj = Activator.CreateInstance(testType) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure><ol start="2"><li>有参构造</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type testType = typeod(Test);</span><br><span class="line"><span class="comment">// 参数1：要实例化对象的Type</span></span><br><span class="line"><span class="comment">// 参数2：需要的参数</span></span><br><span class="line">Test testObj = Activator.CreateInstance(testType, <span class="number">99</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure><h3 id="类库文件"><a href="#类库文件" class="headerlink" title="类库文件"></a>类库文件</h3><p><strong>类库文件</strong>（<code>.dll</code>）可以看成一种代码仓库，它提供给使用者一些可以直接拿来用的<em>变量</em>、<em>函数</em>或<em>类</em>。我们可以创建类库文件来建立引用对象，他就是一个用来引用的对象，无法直接运行。</p><p>创建类库文件：新建控制台程序 -&gt; 创建xx库文件。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>特性</strong>的本质是个<strong>类</strong>。我们可以利用特性类为元数据（一个类、成员变量、成员方法）添加额外信息。之后可以通过反射来获取这些额外信息。</p><h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><ul><li><p>特点：继承特性基类<code>Attribute</code></p></li><li><p>命名：<code>类的含义+Attribute</code></p></li></ul><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 特性中的成员，一般根据需求来写</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.info = info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>限制自定义特性的使用范围</li></ul><p>通过为特性类加特性限制其使用范围，具体操作如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：AttributeTargets —— 特性能够用在哪些地方</span></span><br><span class="line"><span class="comment">// 参数2：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</span></span><br><span class="line"><span class="comment">// 参数3：Inherited —— 特性是否能被派生类和重写成员继承</span></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br></pre></td></tr></table></figure><p>其中，<code>|</code>是位或运算符，这里表示可以同时使<code>Class</code>和<code>Struct</code>都加上特性。不用<code>&amp;&amp;</code>的原因是：这二者都是枚举类型，对应二进制数，要用<code>|</code>对其操作，而<code>&amp;&amp;</code>对应<code>bool</code>类型。</p><h3 id="特性的使用"><a href="#特性的使用" class="headerlink" title="特性的使用"></a>特性的使用</h3><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[特性名(参数列表)]</span><br></pre></td></tr></table></figure><p>其中，系统自动省略了特性名中的<code>Attribute</code>。</p><p>本质上就是在调用特性类的构造函数，它可以写在<em>类</em>、<em>函数</em>、<em>变量</em>上一行，用于表示他们具有该特性信息。</p><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;类&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;成员变量&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;函数&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"> [MyCustom(<span class="string">&quot;函数参数&quot;</span></span>)]<span class="built_in">int</span> a )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 具体逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于特性还有以下几个方法：</p><ul><li>判断是否使用了某个特性</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：特性的类型</span></span><br><span class="line"><span class="comment">// 参数2：代表是否搜索继承链（属性和事件忽略此参数）</span></span><br><span class="line"><span class="keyword">if</span>(t.IsDefined(<span class="keyword">typeof</span>(MyCustomAttribute), <span class="literal">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;t应用了MyCustom特性&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取<code>Type</code>元数据中的所有特性</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>[] array = t.GetCustomAttributes(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="系统自带特性"><a href="#系统自带特性" class="headerlink" title="系统自带特性"></a>系统自带特性</h3><ul><li><em>过时特性</em>：用于提示用户使用的方法等成员已经过时，建议使用新方法</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：调用过时方法时，提示的内容</span></span><br><span class="line"><span class="comment">// 参数2：true - 使用该方法时报错；false - 使用该方法时警告</span></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;某方法已经过时了，请使用新方法&quot;</span>, false)</span>]</span><br></pre></td></tr></table></figure><ul><li><em>调用者信息特性</em>（有3种）：用于<code>try-catch</code>中的<code>catch</code>显示捕获的异常信息的位置，一般用在标记函数的参数。</li></ul><p>需要引用命名空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br></pre></td></tr></table></figure><p>以下是3种调用者信息特性的写法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.哪个文件调用</span></span><br><span class="line">[<span class="meta">CallerFilePath</span>]</span><br><span class="line"><span class="comment">// 2.哪一行调用</span></span><br><span class="line">[<span class="meta">CallerLineNumber</span>]</span><br><span class="line"><span class="comment">// 3.哪个函数调用</span></span><br><span class="line">[<span class="meta">CallerMemberName</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：这三个特性在使用时都需要给被使用的变量赋一个默认值</strong>，如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CallerFilePath</span>]<span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><em>条件编译特性</em>：用于有时想执行有时不想执行的代码，和预处理器<code>#define</code>配合使用（见 入门及基础 &#x2F; 辅助功能 &#x2F; 预处理器指令）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fun</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;Fun&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Fun执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em>外部dll包特性</em>：用来标记非<code>.Net</code>(C#) 的函数，表明该函数在一个外部的<code>DLL</code>（可执行代码文件）中定义，一般用来调用<code>C</code>或者<code>C++</code>的包写好的方法。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Test.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>extern</code>表示该方法的实现是在外部的非托管代码中，即存在于指定的<code>DLL</code>中。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>迭代器</strong>是一种设计模式，提供一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的标识。想使用<code>foreach</code>遍历，必须实现迭代器。</p><p>比如我有一个自定义类，它里面有一个私有的<code>List[]</code>，通过实现迭代器，就可以<strong>对外暴露遍历的能力</strong>，外部不需要知道数组的存在、不需要知道数组的索引 &#x2F; 长度，只需要用 <code>foreach</code> 就能逐个拿到数组里的元素。</p><p>接下来，分别介绍标准迭代器的实现方法和语法糖的形式。</p><h3 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h3><p><strong>关键接口：IEnumerator, IEnumerable</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> position = <span class="number">-1</span>; <span class="comment">// 遍历光标，初始为-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IEnumerable接口实现：返回枚举器接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 调用重置光标的方法</span></span><br><span class="line">Reset();</span><br><span class="line"><span class="comment">// this指实例对象list，因为实现了接口，所以这个对象本身即是集合，也是枚举器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IEnumerator接口实现</span></span><br><span class="line"><span class="comment">// 得到当前list里的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> list[position];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动光标的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">++position;</span><br><span class="line"><span class="comment">// 判断是否溢出</span></span><br><span class="line"><span class="keyword">return</span> position &lt; list.Length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重置光标的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">position = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CustomList list = <span class="keyword">new</span> CustomList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foreach</code>本质：</p><ol><li>先实现<code>in</code>后面这个对象的<code>IEnumerable</code>接口，调用<code>GetEnumerator</code>方法，获取<code>IEnumerator</code>枚举器</li><li>执行得到这个<code>IEnumerator</code>对象中的<code>MoveNext</code>方法，只要<code>MoveNext</code>方法返回值为<code>true</code>就会得到<code>Current</code>，然后赋值给<code>item</code></li></ol><h3 id="用yield-return语法糖实现迭代器"><a href="#用yield-return语法糖实现迭代器" class="headerlink" title="用yield return语法糖实现迭代器"></a>用yield return语法糖实现迭代器</h3><p><code>yield return</code>是<code>C#</code>提供给我们的语法糖，可以简化迭代器的实现。其中的关键接口只有<code>IEnumerable</code>。</p><ul><li>为普通类实现迭代器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CustomList2</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomList2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IEnumerable接口实现：返回枚举器接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>yield return</code>可以理解为暂时返回，保留当前状态。其实本质还是系统生成了标准迭代器中的<code>MoveNext()</code>等方法。</p><ul><li>为泛型类实现迭代器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"><span class="keyword">params</span> T[] array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.array = array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见语法糖"><a href="#常见语法糖" class="headerlink" title="常见语法糖"></a>常见语法糖</h2><h3 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h3><p><code>var</code>是一种编译期<strong>类型推断关键字</strong>（语法糖），它可以用来表示任意类型的变量，但不是一个实际的数据类型。</p><p><strong>注意：</strong></p><ol><li><code>var</code><strong>不能</strong>作为<strong>类的成员</strong>使用，因为类的成员必须指明变量类型，<strong>只能</strong>用于<strong>临时变量</strong>申明时，也就是一般写在函数语句块中</li><li><code>var</code>必须初始化</li></ol><p>需要特别说明的是， <code>var</code>只是用来写代码时偷懒的工具，一旦确定类型就不可变，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">100</span>; <span class="comment">// 编译期推断num1的类型是int</span></span><br><span class="line">num1 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 编译报错！因为var只是“语法糖”，实际类型是int，不能赋值字符串</span></span><br></pre></td></tr></table></figure><p>而<code>object</code> 是<code>C#</code>所有类型的基类，类型确定后也可以改变，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> num2 = <span class="number">100</span>; <span class="comment">// num2的类型是object，值是装箱后的int</span></span><br><span class="line">num2 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 编译正常！object可以接收任意类型的值</span></span><br></pre></td></tr></table></figure><p>除此之外，<code>var</code>变量还可以申明为自定义的<strong>匿名类</strong>，实例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;小明&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：里面不能写函数相关的内容，只有成员变量</strong></p><h3 id="设置初始值"><a href="#设置初始值" class="headerlink" title="设置初始值"></a>设置初始值</h3><ol><li>设置对象初始值</li></ol><p>申明对象时可以通过直接写大括号的形式初始化<strong>公共成员变量属性</strong>。</p><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">100</span>)&#123; sex = <span class="literal">true</span>, Age = <span class="number">19</span>, Name = <span class="string">&quot;meimei酱&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置集合初始值</li></ol><p>申明集合对象时也可以通过大括号直接初始化<strong>内部属性</strong>。</p><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&quot;123&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="string">&quot;222&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p><strong>值类型</strong>不能赋值为空<code>null</code>，但是申明时加上一个<code>?</code>就可以了，具体如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>与可空类型相关的方法如下：</p><ul><li>判断是否为空</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>安全获取可空类型值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? <span class="keyword">value</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 如果为空，返回默认值，不填默认为0</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.GetValueOrDefault(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><ul><li>判断是否为空</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o?.ToString();</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(o != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">o.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个与之相关的符号 —— <strong>空合并操作符</strong> <code>??</code></p><p>语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左边值 ?? 右边值</span><br></pre></td></tr></table></figure><p>使用结果是：如果左边值为<code>null</code>就返回右边值，否则返回左边值。</p><h3 id="单句代码省略写法"><a href="#单句代码省略写法" class="headerlink" title="单句代码省略写法"></a>单句代码省略写法</h3><p>语法如下：</p><ul><li>属性中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> =&gt; <span class="string">&quot;大鱼飞九草&quot;</span>;</span><br><span class="line"><span class="keyword">set</span> =&gt; sex = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> =&gt; x + y;</span><br></pre></td></tr></table></figure><p>也可以像这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> =&gt; Console.WriteLine(str);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇文章将记录除了面向对象外的其他c#笔记。</summary>
    
    
    
    <category term="高级编程语言/C#" scheme="http://tymblog.yuzhiboliuhua.cn/categories/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/"/>
    
    
    <category term="CSharp" scheme="http://tymblog.yuzhiboliuhua.cn/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/a91eaa72.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/a91eaa72.html</id>
    <published>2025-12-16T08:18:00.000Z</published>
    <updated>2026-02-28T13:20:11.073Z</updated>
    
    <content type="html"><![CDATA[<p>这个是更详细的教程，主要用到第六条：<br>[GIT教程-廖雪峰](<a href="https://liaoxuefeng.com/books/git/introduction/index.html">简介 - Git教程 - 廖雪峰的官方网站</a>)</p><h1 id="将Git仓库和GitHub仓库关联"><a href="#将Git仓库和GitHub仓库关联" class="headerlink" title="将Git仓库和GitHub仓库关联"></a>将Git仓库和GitHub仓库关联</h1><p>要用Git往GitHub上上传，需要建立本地Git仓库与GitHub远程仓库之间的“安全身份认证通道”，同时实现“唯一身份识别 + 加密数据传输”，最终能让我们安全、专属地向GitHub推送 &#x2F; 拉取代码。</p><p>以下是关联步骤：</p><ol><li>创建SSH Key<ul><li>创建步骤<ul><li>在任意文件夹下右键打开Git Bash，输入<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>，需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可。</li><li>登录GitHub，通过右上角头像 -&gt; 设置 -&gt; SSH与GPG公钥 -&gt; 新建SSH密钥，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容（通过<code>cat ~/.ssh/id_rsa.pub</code>查看） -&gt; 添加密钥</li></ul></li></ul></li></ol><h1 id="用Git上传文件"><a href="#用Git上传文件" class="headerlink" title="用Git上传文件"></a>用Git上传文件</h1><ol><li><p>准备好需要上传的文件（工程项目只需准备<code>Assets</code>、<code>Packages</code>和<code>Projectsettings</code>），将要用的文件保存在一个新的文件夹里</p></li><li><p>接下来是关联该文件夹与GitHub中的仓库的步骤，如果已完成直接跳转第<code>3</code>步：</p><ul><li>初始化本地Git仓库：<code>git init</code></li></ul></li><li><p>在这个文件夹中右键点击 <code>git bash</code>：</p><ul><li>暂存：<code>git add .</code></li><li>本地提交：<code>git commit -m &quot;备注&quot;</code></li><li>将本地当前分支强制重命名为 <code>main</code>：<code>git branch -M main</code></li><li>关联远程仓库：<code>git remote add origin HTTPS</code></li><li>推送到 GitHub 远程仓库：<code>git push origin main</code>（第一次推送：<code>git push -u origin main </code>）</li></ul></li></ol><h1 id="用Git克隆文件"><a href="#用Git克隆文件" class="headerlink" title="用Git克隆文件"></a>用Git克隆文件</h1><ol><li>克隆：<code>git clone ssh</code></li></ol>]]></content>
    
    
    <summary type="html">本篇文章是GIT的学习笔记，供个人学习。</summary>
    
    
    
    <category term="blog" scheme="http://tymblog.yuzhiboliuhua.cn/categories/blog/"/>
    
    
    <category term="Git" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Git/"/>
    
    <category term="GitHub" scheme="http://tymblog.yuzhiboliuhua.cn/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>2025 Unity中国开发挑战赛</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/1d3b1b44.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/1d3b1b44.html</id>
    <published>2025-12-15T08:15:00.000Z</published>
    <updated>2026-02-15T11:50:10.931Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/BlueBlouseCat/Survivor">GitHub项目成品及工程仓库</a></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>刚学习完面向对象以及Unity核心，跟着唐老狮做了一个坦克迷宫的游戏（详情见<a href="https://github.com/BlueBlouseCat/TankGame">GitHub仓库之TankGame</a>），一起学习的同门带土兄发现Unity正在举办开发者挑战赛，抱着综合运用一下学到的知识的心态，我报名了这项比赛，没想到取得了不错的成绩。。</p><h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><p>我想做一个跑酷类型的游戏，与传统跑酷类似的是玩家不移动而地图移动，不过我找到的美术资源比较适合做玩家上下移动而非左右移动，这算是一个比较新的点，也因为这个原因在开发过程中遇到了一些小问题。。</p><h2 id="游戏介绍"><a href="#游戏介绍" class="headerlink" title="游戏介绍"></a>游戏介绍</h2><p>（详情参见GitHub仓库中的说明文档，此处仅展示游戏截图）</p><p><img src="https://tymimg.yuzhiboliuhua.cn/Unity%20CN/2.jpg" alt="游戏截图1"></p><h2 id="代码部分展示"><a href="#代码部分展示" class="headerlink" title="代码部分展示"></a>代码部分展示</h2><p>面板的处理不细说了，主要聊聊代码部分。<br>游戏中的代码包含<code>3</code>个部分：</p><ul><li><code>BeginScene</code></li><li><code>GameScene</code></li><li><code>Data</code></li></ul><p>按场景和功能分类，对于场景来说，每部分代码控制UI面板以及背景音乐。</p><h3 id="BeginScene"><a href="#BeginScene" class="headerlink" title="BeginScene"></a>BeginScene</h3><h4 id="面板基类"><a href="#面板基类" class="headerlink" title="面板基类"></a>面板基类</h4><p>由于游戏中会出现许许多多的面板，我们不妨设置一个面板基类，用于实现所有面板要处理的共同逻辑。其余面板只需继承这个基类面板，在其基础上补充功能即可。</p><p>以下是一个面板基类：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasePanel</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 单例模式：两个关键的静态成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance =&gt; instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowMe</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 隐藏自己的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HideMe</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较需要注意的点在于：</p><ol><li><p>虚函数：供子类重写显示自己和隐藏自己的方法</p></li><li><p>单例模式：由于运行时<strong>面板全局唯一</strong>的特性，可以采用单例模式，简化代码。</p></li><li><p>泛型：整个游戏中会有很多面板，采用泛型可以将面板的共同逻辑封装在一个面板基类中，简化代码逻辑。</p></li></ol><ul><li><p>之前<code>instance</code>的实例化是<code>new T()</code>，不过现在这个面板基类继承了<code>MonoBehaviour</code>就不能直接<code>new</code>了；</p></li><li><p>那么<code>instance</code>的赋值应该在哪实现呢？在<code>Awake()</code>中。让这个<code>instance</code>的值为当前这个脚本所挂载的面板，也就是<code>this</code>；</p></li><li><p>问题又出现了，当前的<code>this</code>类型是<code>T</code>，而<code>T</code>的类型是子类继承时决定的，现在让他为<code>this</code>也就是<code>BasePanel</code>，显然与<code>T</code>类型不一样，因此，需要<code>as</code>成<code>T</code>；</p></li><li><p>使用<code>as</code>的条件是<code>T</code>是一个类对象，因此，需要进行泛型约束，加上<code>where T : class</code>。</p></li></ul><h4 id="其他面板"><a href="#其他面板" class="headerlink" title="其他面板"></a>其他面板</h4><p>其他面板（<code>BeginPanel</code>开始界面、<code>RankPanel</code>排行榜界面、<code>SettingPanel</code>设置界面）继承了面板基类，注意点如下：</p><ul><li>注意显隐，避免穿透</li><li>排行榜控件较多，可以直接通过代码查找</li><li><code>text</code>控件需要的是<code>string</code>类型，遇到分数时记得使用<code>ToString()</code>函数转变</li><li>得到时间时得到的是秒，需要把秒数转化为<em>时 分 秒</em>的格式存储起来，具体操作如下：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> time = (<span class="built_in">int</span>)list[i].time;</span><br><span class="line"><span class="comment">//默认是0，初始化为空方便拼接</span></span><br><span class="line">labTime[i].text = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//得到 几个小时</span></span><br><span class="line"><span class="keyword">if</span> (time / <span class="number">3600</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">labTime[i].text += time / <span class="number">3600</span> + <span class="string">&quot;时&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (time % <span class="number">3600</span> / <span class="number">60</span> &gt; <span class="number">0</span> || labTime[i].text != <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">labTime[i].text += time % <span class="number">3600</span> / <span class="number">60</span> + <span class="string">&quot;分&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">labTime[i].text += time % <span class="number">60</span> + <span class="string">&quot;秒&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h4><p>同样用到单例模式，初始化是设置音乐大小和开关，内有改变音量和开关音乐的方法。</p><h3 id="GameScene"><a href="#GameScene" class="headerlink" title="GameScene"></a>GameScene</h3><p><code>GameScene</code>包含部分如下：</p><ul><li><code>AnimationBG</code>背景的移动动画</li><li><code>Object</code>物体：<ul><li><code>People</code>人物</li><li><code>Reward</code>奖励</li><li><code>Weapon</code>武器</li></ul></li><li><code>Spawner</code>随机生成</li><li><code>UI</code><ul><li><code>GamePanel</code></li><li><code>LoadPanel</code></li><li><code>LosePanel</code></li><li><code>QuitPanel</code></li><li><code>WinPanel</code></li></ul></li></ul><p>写游戏场景时，我遇到了许许多多的问题，不过经过一次次调试都解决了。</p><p>其中我记忆里比较深刻的问题是人物在移动时通过碰到磁铁道具吸引的金币总是到处乱飘，并且最终落点总在人物模型之后。</p><p>思考了很久，问了带领我的青女学长，也向AI寻求帮助都没成功解决。</p><p>最后我发现，因为人物是没有移动的，只是背景有动画，各种武器、奖励、怪物都以一定的速度向左移动，因此，在给物体加上磁力时它具有一个初速度，如果检测到碰撞到磁铁，就应该把物体的初速度置为0。</p><p>想到这个解决办法并看着问题成功解决真的特别特别有成就感！！让我在游戏开发的道路上更加具有信心和挑战精神 &#x3D;v&#x3D;</p><p>其他还有一些初次开发没有注意到的问题，例如：人物移动时应该在某一边界内、子弹的数目应该限量等等问题都是我的小伙伴们试玩发现并指出的~特别感谢大家(￣▽￣)／</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p><code>Data</code>包括三个部分：</p><ul><li><code>GameDataMgr</code>数据管理类</li><li><code>MusicData</code>音乐数据</li><li><code>RankInfo</code>排行榜信息</li></ul><p>其中，数据管理类负责实现各种数据（包括音效数据、排行榜数据）的开启或关闭音乐（音效）、增大或调小音乐（音效）、添加排行榜信息、存储改变后的数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的GameJam是一次难得的经历，虽然没有和其他网络上的人一起合作开发，不过经过限时挑战、独立制作、修复bug、完成游戏的整个过程我因为找不到bug而苦恼过、完成游戏制作而满足过、也因为最终取得不错的成绩而开心过。总之，游戏开发任重道远，希望我保持初心，成为一个更好的 game developer！！</p>]]></content>
    
    
    <summary type="html">第一次自己独立开发游戏，也是第一次参加比赛，很新奇的体验，学到了很多。</summary>
    
    
    
    <category term="项目/比赛" scheme="http://tymblog.yuzhiboliuhua.cn/categories/%E9%A1%B9%E7%9B%AE-%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="游戏开发" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="#Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>游戏开发</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/f965247b.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/f965247b.html</id>
    <published>2025-11-14T02:21:00.000Z</published>
    <updated>2026-02-20T03:04:06.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="UI设置思路"><a href="#UI设置思路" class="headerlink" title="UI设置思路"></a>UI设置思路</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>在Project窗口中创建重要文件夹：<ul><li>Resources</li><li>Scripts</li><li>StreamingAssets：用于存放json数据文件</li><li>ArtRes</li></ul></li><li>创建UGUI对象，设置Canvas（可以把EventSystem和用于渲染UI的摄像机作为Canvas的子对象，防止被删除）<ul><li>设置渲染模式，关联UI摄像机（只渲染UI层，Depth Only，移除音效组件）</li><li>修改主摄像机参数（取消渲染UI层）</li><li>Canvas设置分辨率自适应（缩放模式）</li><li>分辨率根据美术的sprite图来设置，没有就是1920x1080</li><li>分析是竖屏游戏还是横屏游戏，横屏高不变，分辨率自适应来Match高</li></ul></li></ol><h3 id="面板基类"><a href="#面板基类" class="headerlink" title="面板基类"></a>面板基类</h3><p>假设我们的面板都需要实现显示、隐藏自己、淡入淡出的功能。我们可以用一个面板基类来控制。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BasePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 整体控制淡入淡出的画布组 组件</span></span><br><span class="line"><span class="keyword">private</span> CanvasGroup canvasGroup;</span><br><span class="line"><span class="comment">// 淡入淡出的速度</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> alphaSpead = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开始显示</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isShow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当自己淡出成功的时候执行的函数</span></span><br><span class="line"><span class="keyword">private</span> UnityAction hideCallBack;</span><br><span class="line"></span><br><span class="line"><span class="function">protect <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 一开始获取面板上挂载的组件</span></span><br><span class="line"><span class="comment">// 如果没有 我们通过代码为他添加一个</span></span><br><span class="line">canvasGroup = <span class="keyword">this</span>.GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line"><span class="keyword">if</span>(canvasGroup == <span class="literal">null</span>)</span><br><span class="line">canvasGroup = <span class="keyword">this</span>.gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">protect <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要用于初始化按钮事件的监听等等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowMe</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">isShow = <span class="literal">true</span>;</span><br><span class="line">canvasGroup.alpha = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HideMe</span>(<span class="params">UnityAction callBack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">isShow = <span class="literal">false</span>;</span><br><span class="line">canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 记录当淡出成功时要执行的委托函数</span></span><br><span class="line">hideCallBack = callBack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 淡入</span></span><br><span class="line"><span class="keyword">if</span>(isShow &amp;&amp; canvasGroup.alpha != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">canvasGroup.alpha += alphaSpeed * Time.deltaTime;</span><br><span class="line"><span class="keyword">if</span>(canvasGroup.alpha &gt;= <span class="number">1</span>)</span><br><span class="line">canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 淡出</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!isShow)</span><br><span class="line">&#123;</span><br><span class="line">canvasGroup.alpha -= alphaSpeed * Time.deltaTime;</span><br><span class="line"><span class="keyword">if</span>(canvasGroup.alpha &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">canvasGroup.alpha = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 应该让管理器 删除自己</span></span><br><span class="line">hideCallBack?.Invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UI管理器"><a href="#UI管理器" class="headerlink" title="UI管理器"></a>UI管理器</h3><p>因为UGUI制作的面板都是动态的创建和删除的，所以我们可以用一个UI管理器来整体管理面板的显示、隐藏、获取。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UIManager instance = <span class="keyword">new</span> UIManager();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance =&gt; instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储面板的容器</span></span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt; panelDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, BasePanel&gt;();</span><br><span class="line"><span class="comment">// 应该一开始 就得到我们的Canvas对象</span></span><br><span class="line"><span class="keyword">private</span> Transform canvasTrans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 得到场景上创建好的Canvas对象</span></span><br><span class="line">canvasTrans = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line"><span class="comment">// 让Canvas对象 过场景不移除</span></span><br><span class="line"><span class="comment">// 我们都是通过 动态创建和动态删除来显示、隐藏面板的 所以不用删除它</span></span><br><span class="line">GameObject.DontDestroyOnLoad(canvasTrans.gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示面板</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">ShowPanel</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T:BasePanel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 我们只需要保证 泛型T的类型和面板名一致</span></span><br><span class="line"><span class="built_in">string</span> panelName = <span class="keyword">typeof</span>(T).Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已经有显示着的该面板了 如果有直接给外部使用</span></span><br><span class="line"><span class="keyword">if</span>(panelDic.ContainsKey(panelName))</span><br><span class="line"><span class="keyword">return</span> panelDic[panelName] <span class="keyword">as</span> T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示面板 就是动态创建面板预设体 设置父对象</span></span><br><span class="line"><span class="comment">// 根据得到的类名 就是我们的预设体面板名 直接动态创建它</span></span><br><span class="line">GameObject panelObj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;UI/&quot;</span> + canvasTrans));</span><br><span class="line">panelObj.transform.SetParent(canvasTrans, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着 就是得到对应的面板脚本 存储起来</span></span><br><span class="line">T panel = panelObj.GetComponent&lt;T&gt;();</span><br><span class="line"><span class="comment">// 把面板脚本存储到 对应容器中 之后方便获取</span></span><br><span class="line">panelDic.Add(panelName, panel);</span><br><span class="line"><span class="comment">// 调用显示自己的逻辑</span></span><br><span class="line">panel.ShowMe();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> panel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏面板</span></span><br><span class="line"><span class="comment">// 参数：如果希望淡出就默认传true 如果希望直接隐藏（删除）面板就传false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HidePanel</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">bool</span> isFade = <span class="literal">true</span></span>) <span class="keyword">where</span> T:BasePanel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 根据泛型类型得到面板名字</span></span><br><span class="line"><span class="built_in">string</span> panelName = <span class="keyword">typeof</span>(T).Name;</span><br><span class="line"><span class="comment">// 判断当前显示的面板存不存在于字典中</span></span><br><span class="line"><span class="keyword">if</span>(panelDic.ContainsKey(panelName))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isFade)</span><br><span class="line">&#123;</span><br><span class="line">panelDic[panelName].HideMe(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 面板淡出成功后 希望删除面板</span></span><br><span class="line">GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line"><span class="comment">// 删除面板后从字典移除</span></span><br><span class="line">panelDic.Remove(panelName)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 删除面板</span></span><br><span class="line">GameObject.Destroy(panelDic[panelName].gameObject);</span><br><span class="line"><span class="comment">// 删除面板后从字典移除</span></span><br><span class="line">panelDic.Remove(panelName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得面板</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetPanel</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T:BasePanel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> panelName = <span class="keyword">typeof</span>(T).Name;</span><br><span class="line"><span class="keyword">if</span>(panelDic.ContainsKey(panelName))</span><br><span class="line"><span class="keyword">return</span> panelDic[panelName] <span class="keyword">as</span> T;</span><br><span class="line"><span class="comment">// 如果没有 直接返回空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：使用这种方式必须保证类名和预设体名字一致</strong></p><h3 id="面板实例"><a href="#面板实例" class="headerlink" title="面板实例"></a>面板实例</h3><p>有了上述的面板基类和UI管理器，我们可以正式来实现面板逻辑了。以下以一个提示面板作为示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TipPanel</span> : <span class="title">BasePanel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 确定按钮</span></span><br><span class="line"><span class="keyword">public</span> Button btnSure;</span><br><span class="line"><span class="comment">// 提示文字</span></span><br><span class="line"><span class="keyword">public</span> Text txtInfo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化 按钮事件监听</span></span><br><span class="line">btnSure.onClick.AddListener(() =&gt; &#123;</span><br><span class="line"><span class="comment">// 隐藏自己</span></span><br><span class="line">UIManager.Instance.HidePanel&lt;TipPanel&gt;();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变提示内容的方法 提供给外部使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeInfo</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">txtInfo.text = info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，由于我们的代码没有入口，还需要写一个<code>Main</code>函数，之后我们只需要创建一个空物体取名为Main，再将此脚本拖上去，UI面板就都可以显示了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 显示 提示面板</span></span><br><span class="line">TipPanel tipPanel = UIManager.Instance.ShowPanel&lt;TipPanel&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊部件"><a href="#特殊部件" class="headerlink" title="特殊部件"></a>特殊部件</h2><h3 id="蓄能条"><a href="#蓄能条" class="headerlink" title="蓄能条"></a>蓄能条</h3><p>蓄能条的表现形式是长按蓄能，我们可以通过<code>UGUI</code>里的长按监听事件来完成。</p><p>其中，这里的实现思路是，<code>GamePanel</code>上有一个长按按钮，通过长按它来使<code>GamePanel</code>上的蓄能条改变，为了更好的体现面向对象的思路，我们可以这样操作：</p><ul><li>按钮单独处理抬起、按下逻辑</li><li>按钮中有抬起、按下的事件装载了抬起、按下要实现的具体逻辑</li><li>在<code>GamePanel</code>中实现这里面的具体逻辑</li></ul><p>下面是处理长按按钮的逻辑：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长按按钮脚本 提供两个事件给外部 让外部去处理对应的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LongPress</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerDownHandler</span>, <span class="title">IPointerUpHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> UnityAction upEvent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> UnityAction downEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现IPointerDownHandler的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerDown</span>(<span class="params">PointEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">downEvent?.Invoke();<span class="comment">// 当事件不为空的时候执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现IPointerUpHandler的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerDown</span>(<span class="params">PointEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">upEvent?.Invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再<code>GamePanel</code>脚本上处理具体逻辑：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联长按功能按钮</span></span><br><span class="line"><span class="keyword">public</span> LongPress longPress;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进度条根对象 用于控制显隐</span></span><br><span class="line"><span class="keyword">public</span> GameObject imgRoot;</span><br><span class="line"><span class="comment">// 进度条对象 用于控制进度</span></span><br><span class="line"><span class="keyword">public</span> RectTransform imgBk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向长按功能按钮中的事件加函数</span></span><br><span class="line">longPress.downEvent += BtnDown;</span><br><span class="line">longPress.upEvent += BtnUp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最开始隐藏蓄能条</span></span><br><span class="line">imgRoot.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否按下</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isDown = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 计时</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> nowTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 增加速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> addSpeed = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BtnDown</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">isDown = <span class="literal">true</span>;</span><br><span class="line">nowTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 蓄能条清空</span></span><br><span class="line">imgBk.sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BtnUp</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">isDown = <span class="literal">false</span>;</span><br><span class="line">imgRoot.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isDown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计时</span></span><br><span class="line">nowTime += Time.deltaTime;</span><br><span class="line"><span class="keyword">if</span>( nowTime &gt;= <span class="number">0.2f</span>)</span><br><span class="line">&#123;</span><br><span class="line">imgRoot.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 蓄能条增加</span></span><br><span class="line">imgBk.sizeDelta += <span class="keyword">new</span> Vector2(imgBk.sizeDelta * Time.deltaTime, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>( imgBk.sizeDelta.x &gt;= <span class="number">800</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 蓄满后逻辑略</span></span><br><span class="line"><span class="comment">// 蓄能条清空</span></span><br><span class="line">imgBk.sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p>有两种情况可以做进度条。</p><ol><li>有美术资源（不易被拉伸）——  Image改为填充模式</li><li>无美术资源  ——  按住shift键左对齐，改变宽</li></ol><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p>接下来用<code>UGUI</code>中的滚动视图来制作背包的储存格子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BagPanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BagPanel panel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Button btnClose;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动视图</span></span><br><span class="line"><span class="keyword">public</span> ScrollRect svItems;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">panel = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 动态创建n个图标 作为滚动视图中显示的内容</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">GameObject item = Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Item&quot;</span>));</span><br><span class="line"><span class="comment">// 设置这些图标的父对象 便于管理位置变化</span></span><br><span class="line">item.transform.SetParent(svItems.content, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 设置格子的位置：初始位置加格子间隔</span></span><br><span class="line">item.transform.localPosition = <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">-10</span>, <span class="number">0</span>) + <span class="keyword">new</span> Vector3(i % <span class="number">4</span> * <span class="number">160</span> , -i / <span class="number">4</span> * <span class="number">160</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置content的高</span></span><br><span class="line">svItem.content.sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">0</span>, Mathf.CeilToInt(<span class="number">30</span> / <span class="number">4f</span>) * <span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">btnClose.onClick.AddListener(() =&gt; &#123;</span><br><span class="line">gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始隐藏自己</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摇杆"><a href="#摇杆" class="headerlink" title="摇杆"></a>摇杆</h3><p>整个功能分为两步：</p><ul><li>UI界面摇杆的控制（向量、<code>EventTrigger</code>）</li><li>摇杆移动带动玩家移动的具体逻辑（四元数）</li></ul><p>我们先来实现第一步：</p><ol><li>先为摇杆子对象添加<code>EventTrigger</code></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GamePanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> RectTransform imgJoy;</span><br><span class="line"><span class="comment">// 摇杆上的事件相关</span></span><br><span class="line"><span class="keyword">public</span> EventTrigger et;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 为摇杆注册事件</span></span><br><span class="line"><span class="comment">// 拖动中</span></span><br><span class="line">EventTrigger.Entry en = <span class="keyword">new</span> EventTrigger.Entry();</span><br><span class="line">en.eventID = EventTriggerType.Drag;</span><br><span class="line">en.callback.AddListener(JoyDrag);</span><br><span class="line">et.triggers.Add(en);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束拖动</span></span><br><span class="line">EventTrigger.Entry en = <span class="keyword">new</span> EventTrigger.Entry();</span><br><span class="line">en.eventID = EventTriggerType.EndDrag;</span><br><span class="line">en.callback.AddListener(EndJoyDrag);</span><br><span class="line">et.triggers.Add(en);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">JoyDrag</span>(<span class="params">BaseEventData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PointerEventData eventData = data <span class="keyword">as</span> PointerEventData;</span><br><span class="line"><span class="comment">// 屏幕坐标转UI坐标</span></span><br><span class="line">Vector2 nowPos;</span><br><span class="line">RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line">imgJoy.parent <span class="keyword">as</span> RectTransform,</span><br><span class="line">eventData.position,</span><br><span class="line">eventData.enterEventCamera,</span><br><span class="line"><span class="keyword">out</span> nowPos );</span><br><span class="line">imgJoy.localPosition = nowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前位置与中心点的向量模长是否超出边界</span></span><br><span class="line"><span class="keyword">if</span>(imgJoy.anchoredPosition.magnitude &gt; <span class="number">170</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 拉回来</span></span><br><span class="line"><span class="comment">// 单位向量 * 长度 = 临界位置</span></span><br><span class="line">imgJoy.anchoredPosision = imgJoy.anchoredPosition.normalized * <span class="number">170</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让玩家转动</span></span><br><span class="line">player.Move(imgJoy.anchoredPosition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EndJoyDrag</span>(<span class="params">BaseEventData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 回归中心点</span></span><br><span class="line">imgJoy.anchoredPosition = Vector2.zero;</span><br><span class="line"><span class="comment">// 停止移动，传零向量即可</span></span><br><span class="line">player.Move(Vector2.zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再处理控制玩家移动相关逻辑：</p><p>在<code>PlayerObject</code>的脚本上：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerObject</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> roundSpeed = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前的方向</span></span><br><span class="line"><span class="keyword">private</span> Vector3 nowMoveDir = Vector3.zero;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到摇杆方向 方便处理后续转动逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">nowMoveDir.x = dir.x;</span><br><span class="line">nowMoveDir.y = <span class="number">0</span>;</span><br><span class="line">nowMoveDir.z = dir.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(nowMoveDir != Vector3.zero)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 玩家朝面朝向移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vwctor3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line"><span class="comment">// 不停地朝目标方向转向</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, Quaternion.LookRotation(nowMoveDir), roundSpeed * Time.deltaTime);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用UI-Toolkit和UI-Builder"><a href="#使用UI-Toolkit和UI-Builder" class="headerlink" title="使用UI Toolkit和UI Builder"></a>使用UI Toolkit和UI Builder</h2><p><code>UI Toolkit</code> 和 <code>UI Builder</code> 是 Unity 中新一代的 UI 开发工具链 —— 简单来说，<strong>UI Toolkit 是底层框架，UI Builder 是可视化编辑器</strong>，二者配合替代了传统的 UGUI，尤其适合做编辑器扩展和游戏内 UI。</p><p>接下来，我将简单的介绍<code>UI Toolkit</code> 和 <code>UI Builder</code> 的使用方法（以下实例是编辑器扩展相关功能）：</p><ol><li><p>在Asset文件夹下创建一个Editor文件夹（只在编辑器模式下有，不被打包）</p></li><li><p>再在Editor文件夹下创建一个UI Builder文件夹，这时就可以创建UI Toolkit - Editor Window</p></li></ol><p>这时，里面就会有3个可以打开的文件：</p><ul><li>C#</li><li>UXML</li><li>USS</li></ul><p>比较常用的是C#。</p><p>接着，在Assets&#x2F;Editor&#x2F;UI Builder&#x2F;Item Editor(Visual Tree Asset)文件下，双击就可以打开编辑窗口。这个窗口相当于是Unity内置的一个编辑器，接下来介绍基础的使用方法。</p><ol><li>将Library中的Visual Element当作一个空物体使用，拖入Hierarchy窗口。（在右侧的Inspector窗口中可以修改命名，拉伸方式等）</li><li>Viewport中将想修改的地方选中，可以根据名字旁边的符号查看他的样式，符号的意思分别是：排列方向，对其方式（3种）</li></ol><h1 id="主玩家相关"><a href="#主玩家相关" class="headerlink" title="主玩家相关"></a>主玩家相关</h1><h2 id="人物移动"><a href="#人物移动" class="headerlink" title="人物移动"></a>人物移动</h2><ol><li>2D横板平台跳跃：<code>AddForce</code>添加一个力</li><li>伪Y轴游戏：移动坐标。</li></ol><p>关键代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Movement</span>()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    rb.MovePosition(rb.position + movementInput * speed * Time.deltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，<code>rb</code>是<code>RigidBody2D</code>组件，调用了内置方法<code>MovePosition</code>，参数传最开始的位置  + 输入方向 * 速度 * 帧间隔时间。</p><p>并且，这个函数因为用到了物理系统，必须在<code>FixedUpdate()</code> 中调用，它会在下一个物理步长中平滑地将刚体移动到目标位置并且自动处理碰撞逻辑。</p><h2 id="边界判断及摄像机跟随"><a href="#边界判断及摄像机跟随" class="headerlink" title="边界判断及摄像机跟随"></a>边界判断及摄像机跟随</h2><p>有些游戏会涉及到有关玩家的移动，这时候可能会因为玩家移动或者分辨率的原因使玩家不能保持在屏幕内，这时需要处理一定的游戏逻辑来控制主玩家在屏幕范围内。</p><hr><p>思路如下：</p><p><img src="https://tymimg.yuzhiboliuhua.cn/GameDevelopment/Screen.png" alt="边界判断"></p><p>记录玩家之前的位置和玩家现在的位置，判断玩家当前的位置，如果当前位置超出了屏幕范围，则把玩家位置拉回之前的位置。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前世界坐标转屏幕的位置</span></span><br><span class="line"><span class="keyword">private</span> Vector3 nowPos;</span><br><span class="line"><span class="comment">// 位移前玩家的位置</span></span><br><span class="line"><span class="keyword">private</span> Vector3 frontPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 其余逻辑省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在位移之前 记录之前的位置</span></span><br><span class="line">frontPos = <span class="keyword">this</span>.transform.position;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位移逻辑省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动后进行极限判断</span></span><br><span class="line">nowPos = Camera.main.WorldToScreen(<span class="keyword">this</span>.transform.position);</span><br><span class="line"><span class="comment">// 左右 溢出判断</span></span><br><span class="line">    <span class="keyword">if</span>(nowPos.x &lt;= <span class="number">0</span> || nowPos.x &gt;= Screen.width)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(frontPos.x, <span class="keyword">this</span>.transform.position.y, <span class="keyword">this</span>.transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上下 溢出判断</span></span><br><span class="line">    <span class="keyword">if</span>(nowPos.y &lt;= <span class="number">0</span> || nowPos.y &gt;= Screen.height)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">this</span>.transform.position = <span class="keyword">new</span> Vector3(<span class="keyword">this</span>.transform.position.x, <span class="keyword">this</span>.transform.position.y, frontPos.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，如果人物移动时希望<strong>摄像机跟随</strong>，直接在<code>Windows -&gt; Package Manager</code>搜索<code>Cinemachine</code>安装。再创建一个<code>Cinemachine</code>，选择<code>2D Camera</code>，设置它的<code>Follow</code>和<code>Look At</code>对象。</p><p>限制摄像机范围的时候，需要在<code>Cinaemachine VirtualCamera</code>这个组件中的<code>Add Extension</code>中选择<code>Cinemachine Confiner</code>，此时会自动添加两个脚本。</p><p>我们的游戏可能采用多个场景，我们需要给这些场景都设置碰撞边界：为一个场景创建空物体命名为<code>Bounds</code>，为其添加<code>Polygon Collider 2D</code>编辑区域，并设置Points的四个角使其为整数点，勾选<code>Is Trigger</code>。</p><p>不过，我们现在又面临另一个问题：不同场景中的物体不能相互关联，也就是说<code>Bounds</code>物体没有办法与<code>Cinemachine Confiner</code>关联，这时我们就可以通过代码控制每一次加载场景时，通过代码在场景加载好之前将二者关联。以下是实现思路：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Cinemachine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwitchBounds</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//T000后面要改  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span>  </span><br><span class="line">    &#123;        SwitchConfinerShape();  </span><br><span class="line">    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SwitchConfinerShape</span>()</span>  </span><br><span class="line">    &#123;        <span class="comment">// 先找到标签一致的物体（代表边界的物体）的碰撞组件  </span></span><br><span class="line">        PolygonCollider2D confinerShape = GameObject.FindGameObjectWithTag(<span class="string">&quot;BoundsConfiner&quot;</span>).GetComponent&lt;PolygonCollider2D&gt;();  </span><br><span class="line">        <span class="comment">// 跟随摄像机的限制范围  </span></span><br><span class="line">        CinemachineConfiner confiner = GetComponent&lt;CinemachineConfiner&gt;();  </span><br><span class="line">                confiner.m_BoundingShape2D = confinerShape;  </span><br><span class="line">        <span class="comment">// 调用该函数在切换场景时清除缓存  </span></span><br><span class="line">        confiner.InvalidatePathCache();  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="跑步与走路切换-融合树实现"><a href="#跑步与走路切换-融合树实现" class="headerlink" title="跑步与走路切换(融合树实现)"></a>跑步与走路切换(融合树实现)</h2><p>要实现按下Shift键从走路切换到跑步，抬起时从跑步切换到走路。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Test : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> dValue = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">animator = <span class="keyword">this</span>.GetComponent&lt;Animator&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">animator.SetFloat(<span class="string">&quot;Speed&quot;</span>, Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>) * dValue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Input.GetKeyDown(KeyCode.LeftShift))</span><br><span class="line">dValue = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(Input.GetKeyUp(KeyCode.LeftShift))</span><br><span class="line">dValue = <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制角色部分旋转"><a href="#控制角色部分旋转" class="headerlink" title="控制角色部分旋转"></a>控制角色部分旋转</h2><p>思路：人物本来就在不停移动，在这个过程中，人物会一直看向一个点。在头部加上一个空对象，指向看向的点，当这个向量旋转时就会得到一个新的点，从而使人物部分旋转</p><p>![[Pasted image 20251208204210.png]]</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Animator animator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Transform headPos;</span><br><span class="line"><span class="comment">// x方向鼠标旋转了多少角度</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> chageAngleX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">animator = <span class="keyword">this</span>.GetComponent&lt;Animator&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 控制左右移动</span></span><br><span class="line">animator.SetFloat(<span class="string">&quot;x&quot;</span>, Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>));</span><br><span class="line">animator.SetFloat(<span class="string">&quot;y&quot;</span>, Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角度累加</span></span><br><span class="line">chageAngleX += Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>);</span><br><span class="line">changeAngleX = Mathf.Clamp(changeAngleX, <span class="number">-30</span>, <span class="number">30</span>);<span class="comment">// 加紧函数限制范围</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorIK</span>(<span class="params"><span class="built_in">int</span> layerIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">animator.SetLookAtWeight(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Vector3 pos = Quaternion.AngleAxis(changeAgleX, Vector3.up) * (headPos.position + headPos.forward * <span class="number">10</span>);</span><br><span class="line">animator.SetLookAtPosition(pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h1><h2 id="2D层级显示"><a href="#2D层级显示" class="headerlink" title="2D层级显示"></a>2D层级显示</h2><p>当做有伪”z”轴的2D游戏时，需要调整各层的显示。</p><p>首先，将Edit-Project Setting-Graphics中的渲染模式改为Custom Axis，排序轴改为<code>X 0 Y 1 Z 0</code></p><ol><li>地板与人物：人物一直显示在地板上方。<ul><li>地板的<code>Sprite Renderer</code>的<code>Layer</code>始终低于人物的<code>Sprite Renderer</code>的<code>Layer</code>。</li></ul></li><li>墙体与人物：人物一直在后方墙体之前，前方墙体之后。<ul><li>后方墙体：和地板设置为同一层</li><li>前方墙体：新建一个<code>Tilemap</code>渲染层，把它的<code>Layer</code>设置到人物的<code>Layer</code>之上</li></ul></li><li>植物与人物：人物从后方经过植物时会被挡住，从前方经过植物时会挡住植物。<ul><li><p>方法1：新建一个<code>Tilemap</code>渲染层，把它的<code>Layer</code>设置与人物的<code>Layer</code>一致。层级一致的情况下会通过轴心点排序。（注意：要把<code>Tilemap</code>上的模式切换为<code>Individual</code>）</p></li><li><p>方法2：直接将植物拖为一个2D对象，更改他的排序方式为<code>Pivot</code></p></li><li><p>这两种方法的特点：</p><ul><li>方法一：方便快速拖动增加很多植物，不过一个菱形格子只能有一棵植物。</li><li>方法二：不是很方便的添加，不过一个菱形格子可以有多棵植物。</li></ul></li></ul></li></ol><h1 id="景观物体相关"><a href="#景观物体相关" class="headerlink" title="景观物体相关"></a>景观物体相关</h1><h2 id="半透明效果"><a href="#半透明效果" class="headerlink" title="半透明效果"></a>半透明效果</h2><p>在游戏中，当我们的人物经过一个景观物体后面时，为了让表现效果更好，我们通常采用使前方的景观物体变成半透明来处理，下面是实现半透明效果的操作流程。</p><p>首先，我们要得到该景观物体上的<code>SpriteRenderer</code>。</p><p>接下来，会使用一个常用来做动画的工具——DoTween</p><p>在Unity Asset Store下载DoTween，点击SetUP，Apply。</p><p>接着我们就能实现这个效果了，核心思路就是：当人物触发碰撞器时，改变alpha通道的值来实现半透明。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> DG.Tweening;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(SpriteRenderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemFader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> SpriteRenderer spriteRenderer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐渐恢复颜色  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FadeIn</span>()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    Color targetColor = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 渐变方法</span></span><br><span class="line">    spriteRenderer.DOColor(targetColor, <span class="number">0.35f</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐渐半透明</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FadeOut</span>()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    Color targetColor = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.45f</span>);  </span><br><span class="line">    spriteRenderer.DOColor(targetColor, <span class="number">0.35f</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h1><h2 id="屏幕坐标-UI本地坐标系"><a href="#屏幕坐标-UI本地坐标系" class="headerlink" title="屏幕坐标 -&gt; UI本地坐标系"></a>屏幕坐标 -&gt; UI本地坐标系</h2><p>想完成屏幕坐标 -&gt; UI本地坐标系（其中，UI本地坐标系的意思是以UI控件左下角为原点的坐标系），需要用到<code>RectTransformUtility</code>这个类。<code>RectTransformUtility</code>是<code>RectTransform</code>的辅助类。</p><p>一般配合拖拽事件使用。</p><p>核心方法：<code>RectTransformUtility.ScreenPointToLocalPointInRectangle</code></p><p>直接以一个例子来讲解：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.EventSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScreenToUI</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDragHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 实现接口中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 参数1：相对父对象，类型是RectTransform</span></span><br><span class="line"><span class="comment">// 参数2：屏幕点</span></span><br><span class="line"><span class="comment">// 参数3：摄像机</span></span><br><span class="line"><span class="comment">// 参数4：最终得到的点</span></span><br><span class="line">Vector2 nowPos;</span><br><span class="line">RectTransformUtility.ScreenPointToLocalPointInRectangle(</span><br><span class="line"><span class="keyword">this</span>.transform.parent <span class="keyword">as</span> RectTransform,</span><br><span class="line">eventData.position,</span><br><span class="line">eventData.enterEventCamera,</span><br><span class="line"><span class="keyword">out</span> nowPos );</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.transform.localPosition = nowPos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这篇文章记录了游戏开发中常用的一些知识点及问题处理方法。</summary>
    
    
    
    <category term="Unity/开发" scheme="http://tymblog.yuzhiboliuhua.cn/categories/Unity-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
    <category term="游戏开发" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件之Transform</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/180b0572.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/180b0572.html</id>
    <published>2025-11-11T12:45:00.000Z</published>
    <updated>2026-02-15T14:34:44.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位置、位移和朝向"><a href="#位置、位移和朝向" class="headerlink" title="位置、位移和朝向"></a>位置、位移和朝向</h1><h2 id="必备知识：Vector3"><a href="#必备知识：Vector3" class="headerlink" title="必备知识：Vector3"></a>必备知识：Vector3</h2><p>Vector3 主要是用来表示三维坐标系中的一个点或是一个向量。</p><ol><li>申明：</li></ol><p><code>Vector3 v = new Vector3();</code></p><p>创建了一个<code>Vector3</code>类的实例<code>v</code>，并调用<code>Vector3</code>的无参构造函数来初始化这个实例，xyz都为0，也可以只传xy，z默认为0</p><ol start="2"><li>计算</li></ol><p>使用运算符重载可以使向量相<strong>加减</strong>，<strong>数乘</strong>，<strong>除</strong>，就是每个向量对应位置相加减，示例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector3 v1 = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Vector3 v2 = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">print(v1 + v2);</span><br><span class="line">print(v1 - v2);</span><br><span class="line">print(v1 * <span class="number">10</span>);</span><br><span class="line">print(v2 / <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) <span class="comment">// +</span></span><br><span class="line">(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>) <span class="comment">// -</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>) <span class="comment">// x*</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// /</span></span><br></pre></td></tr></table></figure><p>常用的向量:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector3.zero <span class="comment">//000</span></span><br><span class="line">Vector3.right <span class="comment">//100</span></span><br><span class="line">Vector3.left <span class="comment">//-100</span></span><br><span class="line">Vector3.forward <span class="comment">//001</span></span><br><span class="line">Vector3.back <span class="comment">//00-1</span></span><br><span class="line">Vector3.up <span class="comment">//010</span></span><br><span class="line">Vector3.down <span class="comment">//0-10</span></span><br></pre></td></tr></table></figure><p><strong>计算两个点之间的距离的方法</strong>：<code>Vector3.Distance(v1, v2);</code></p><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><ul><li>相对世界坐标系：<code>this.transform.position</code></li><li>相对父对象：<code>this.transform.localPosition</code></li></ul><p><strong>注意：位置的赋值不能单独改变xyz，只能整体改变，改变方式如下：</strong></p><p><code>this.transform.position = new Vector3(10, 10, 10);</code></p><p><strong>也可以像这样：</strong></p><p><code>this.transform.position = Vector3.up * 10;</code></p><p>如果只想改一个值x，yz想和原有坐标保持一致，可以这样处理：</p><p><em>方式1：直接赋值</em></p><p><code>this.transform.position = new Vector3(19, this.transform.position.y, this.transform.position.z);</code></p><p><em>方式2：先取出来再赋值</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3 vPos = <span class="keyword">this</span>.transform.localPosition;</span><br><span class="line">vPos.x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">this</span>.transform.localPosition = vPos;</span><br></pre></td></tr></table></figure><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>先来理解坐标系下位移的计算公式：路程 &#x3D; 方向 * 速度 * 时间</p><p><em>方式1：自己计算</em></p><p>最终位置 &#x3D; 当前位置 + 要移动的距离</p><p><code>this.transform.position += Vector3.forward * 1 * Time.deltaTime;</code></p><p><em>方式2：API</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：表示位移多少 路程 = 方向 * 速度 * 时间</span></span><br><span class="line"><span class="comment">// 参数2：表示 相对坐标系（默认相对于自己坐标系）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于世界坐标系的 z轴 动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward * <span class="number">1</span> * Time.deltaTime, Space.World);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于世界坐标系的 自己的面朝向 动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(<span class="keyword">this</span>.transform.forward * <span class="number">1</span> * Time.deltaTime, Space.World);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于自己的坐标系的 自己的面朝向向量移动（一定不会这样使用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于自己的坐标系的 z轴正方向移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward * <span class="number">1</span> * Time.deltaTime, Space.Self); </span><br></pre></td></tr></table></figure><h2 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h2><p><code>this.transform.forward;</code></p><h1 id="角度和旋转"><a href="#角度和旋转" class="headerlink" title="角度和旋转"></a>角度和旋转</h1><h2 id="角度相关"><a href="#角度相关" class="headerlink" title="角度相关"></a>角度相关</h2><ul><li>相对世界坐标角度：<code>this.transform.eulerAngles</code></li><li>相对父对象角度：<code>this.transform.localEulerAngles</code></li></ul><p><strong>注意：欧拉角的取值范围是0~360°，设置角度和设置位置一样，不能单独设置xyz，要一起设置。如果我们希望改变的角度是面板上显示的内容，那一定是改变相对父对象的角度。</strong></p><h2 id="旋转相关"><a href="#旋转相关" class="headerlink" title="旋转相关"></a>旋转相关</h2><p><em>情况一：自转</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1： 每一帧旋转的角度</span></span><br><span class="line"><span class="comment">// 参数2： 不填就是默认相对于自己坐标系进行旋转</span></span><br><span class="line"><span class="keyword">this</span>.transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>) * Time.deltaTime, Space.World);</span><br></pre></td></tr></table></figure><p><em>情况二：相对于某一根轴转</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：相对于的轴</span></span><br><span class="line"><span class="comment">// 参数2：转动的角度 旋转速度*时间</span></span><br><span class="line"><span class="comment">// 参数3：不填默认相对于自己的坐标系进行旋转</span></span><br><span class="line"><span class="keyword">this</span>.transform.Rotate(Vector3.right, <span class="number">10</span> * Time.delataTime, Space.World);</span><br></pre></td></tr></table></figure><p><em>情况3：相对于某一个点</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：相对于的点</span></span><br><span class="line"><span class="comment">// 参数2：相对于哪一个点的哪一条轴</span></span><br><span class="line"><span class="comment">// 参数3：转的角度 旋转速度*时间</span></span><br><span class="line"><span class="keyword">this</span>.transform.RotateAround(Vector3.zero, Vector3.right, <span class="number">10</span> * Time.deltaTime);</span><br></pre></td></tr></table></figure><h1 id="缩放和看向"><a href="#缩放和看向" class="headerlink" title="缩放和看向"></a>缩放和看向</h1><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><ul><li>相对于世界坐标系：<code>this.transform.lossyScale</code></li><li>相对于本地坐标系（父对象）： <code>this.transform.localScale</code></li></ul><p><strong>注意：缩放不能只改xyz，要一起改并且都是相对于父对象的改</strong></p><p>Unity没有提供关于缩放的API，如果想要让缩放发生变化，只能自己去算：<br>&#96;this.transform.localScale +&#x3D; Vector3.one * Time.deltaTime;</p><h2 id="看向"><a href="#看向" class="headerlink" title="看向"></a>看向</h2><ul><li>看向一个点（相当于世界坐标系）<code>this.transform.LookAt(Vector3.zero);</code></li><li>看向一个对象（传入一个对象的Transform信息）<code>this.transform.LookAt(lookAtObj)</code></li></ul><h1 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h1><h2 id="儿子的操作"><a href="#儿子的操作" class="headerlink" title="儿子的操作"></a>儿子的操作</h2><ol><li>获取父对象：<code>this.transform.parent</code>，之后可以获取父对象<code>name</code>等所有信息。</li></ol><hr><ol start="2"><li>设置父对象：</li></ol><ul><li>断绝父子关系：<code>this.transform.SetParent(null);</code></li><li>设置父亲：<code>this.transform.SetParent(GameObject.Find(&quot;Father2&quot;).transform);</code></li></ul><p>设置父亲还有一种重载，在原有的API后面多了一个<code>bool</code>参数，代表是否保留世界坐标的<strong>位置、角度、缩放、信息</strong>。</p><ul><li><code>true</code>代表会<strong>保留</strong>世界坐标下的状态，和父对象进行计算得到本地坐标系的信息。</li><li><code>false</code>代表<strong>不会保留</strong>，会直接把世界坐标系下的位置、角度、缩放直接赋值到本地坐标系下。</li></ul><hr><ol start="3"><li>判断自己的爸爸是谁：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(son.IsChildOf(<span class="keyword">this</span>.transform))</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;是当前脚本依附对象的儿子。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="4"><li>儿子的编号：</li></ol><ul><li>得到自己当前的编号：<code>son.GetSiblingIndex();</code></li><li>把自己设置为第一个儿子：<code>son.SetAsFirstSibling();</code></li><li>把自己设置为最后一个儿子：<code>son.SetAsLastSibling();</code></li><li>把自己设置为指定个儿子：<code>son.SetSiblingIndex(1);</code>   其中，填的编号超出了范围（负数或者更大的数）不会报错，会直接设置成最后一个编号。</li></ul><h2 id="父亲的操作"><a href="#父亲的操作" class="headerlink" title="父亲的操作"></a>父亲的操作</h2><ol><li>获取子对象：</li></ol><ul><li>通过编号得到自己对应的儿子：<code>this.transform.GetChild(0);</code>，返回值是<code>transform</code></li><li>获取知道名字的子对象：<code>this.transform.Find(&quot;Children1&quot;);</code>，之后可以获取子对象<code>name</code>等所有信息。</li></ul><p><strong>注意：</strong></p><ul><li>返回值是儿子的<code>transform</code>信息</li><li><code>transform</code>的<code>Find()</code>方法可以找到失活对象；但<code>GameObject</code>的<code>Find()</code>方法不能找到失活对象</li><li>如果要找到它的孙子，可以通过<code>this.transform.Find(&quot;PM/labPM&quot;);</code>这个API找</li></ul><hr><ol start="2"><li>和自己所有儿子断绝关系：<code>this.transform.DetachChildren();</code></li></ol><hr><ol start="3"><li>遍历儿子：</li></ol><ul><li>得到自己儿子的数量：<code>this.transform.childCount</code><br><strong>注意：</strong> 失活的儿子也会算数量，孙子不会计算进去</li><li>遍历：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.transform.childCount; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h1><h2 id="世界坐标转本地坐标"><a href="#世界坐标转本地坐标" class="headerlink" title="世界坐标转本地坐标"></a>世界坐标转本地坐标</h2><p><strong>作用：可以帮我们判断相对位置</strong></p><ol><li><em>世界坐标系的点</em>转换为<em>相对本地坐标系的点</em></li></ol><ul><li>受缩放影响<br><code>this.transform.InverseTransformPoint(vector3.forward);</code></li></ul><ol start="2"><li><em>世界坐标系的方向</em>转换为<em>相对本地坐标系的方向</em></li></ol><ul><li>不受缩放影响<br><code>this.transform.InverseTransformDirection(vector3.forward);</code></li><li>受缩放影响<br><code>this.transform.InverseTransformVector(vector3.forward);</code></li></ul><h2 id="本地坐标转世界坐标"><a href="#本地坐标转世界坐标" class="headerlink" title="本地坐标转世界坐标"></a>本地坐标转世界坐标</h2><ol><li><em>本地坐标系的点</em>转换为<em>相对世界坐标系的点</em></li></ol><ul><li>受缩放影响<br><code>this.transform.TransformPoint(Vector3.forward);</code></li></ul><ol start="2"><li><em>本地坐标系的方向</em>转换为<em>相对世界坐标系的方向</em></li></ol><ul><li>不受缩放影响<br><code>this.transform.TransformDirection(vector3.forward);</code></li><li>受缩放影响<br><code>this.transform.TransformVector(vector3.forward);</code></li></ul>]]></content>
    
    
    <summary type="html">Transform是Unity中物体的一个基础插件，只要有一个GameObject物体，必然会有Transform插件。游戏对象（GameObject）位移、旋转、缩放、父子关系、坐标转换等相关操作都由它处理。</summary>
    
    
    
    <category term="Unity/插件" scheme="http://tymblog.yuzhiboliuhua.cn/categories/Unity-%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#之面向对象</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/eda74239.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/eda74239.html</id>
    <published>2025-11-10T07:21:00.000Z</published>
    <updated>2026-02-14T08:21:54.356Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象的思想表述了：万物皆对象，用程序来形容对象，用面向对象的思想来编程。</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><strong>封装</strong>是指把对象的 <strong>”数据（字段）“</strong> 和 <strong>”操作数据的方法“</strong> 捆绑在一起，同时隐藏内部细节，只对外暴露接口。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ol><li>类（Class）：特殊语句块，用于包裹形容一类事物</li><li>对象：类声明出来的变量，是引用类型</li></ol><p>以下是一个类的结构：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：类名采用帕斯卡命名法</span></span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 特征——成员变量</span></span><br><span class="line"><span class="comment">// 行为——成员方法</span></span><br><span class="line"><span class="comment">// 保护特征——成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数和析构函数</span></span><br><span class="line"><span class="comment">// 索引器</span></span><br><span class="line"><span class="comment">// 运算符重载</span></span><br><span class="line"><span class="comment">// 静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>访问修饰符：</li></ol><table><thead><tr><th>访问修饰符</th><th>含义</th></tr></thead><tbody><tr><td><strong>public</strong></td><td>公共类</td></tr><tr><td>internal</td><td>只能在该程序集中使用，<strong>命名空间中的类默认为internal</strong></td></tr><tr><td><strong>abstract</strong></td><td>抽象类</td></tr><tr><td>sealed</td><td>密封类</td></tr><tr><td>partial</td><td>分部类</td></tr></tbody></table><p><strong>注意：在同一个命名空间中不能重名</strong></p><h3 id="类和结构体的区别"><a href="#类和结构体的区别" class="headerlink" title="类和结构体的区别"></a>类和结构体的区别</h3><table><thead><tr><th>比较方向</th><th>结构体</th><th>类</th></tr></thead><tbody><tr><td>存储空间</td><td>值（栈）</td><td>引用（空间）</td></tr><tr><td>使用</td><td>变量申明不能指定初始值；不能在内部申明和自己一样的结构体变量</td><td>变量申明可以指定初始值 ；可以在内部申明和自己一样的类</td></tr><tr><td>构造函数</td><td>不能申明无参构造函数；申明有参构造函数后，无参构造不会被顶掉 ；不能申明析构函数；需要在构造函数中初始化所有变量成员</td><td>可以 &#x2F; 会被顶掉 &#x2F; 可以 &#x2F; 随意</td></tr><tr><td>继承</td><td>不能被继承</td><td>可以被继承</td></tr><tr><td>静态</td><td>不存在静态</td><td>可以</td></tr></tbody></table><p>结构体的特别之处：结构体可以继承接口，因为接口是行为的抽象</p><p><strong>如何选择结构体和类？</strong></p><ol><li>想要用<strong>继承和多态</strong>时，直接淘汰结构体，比如玩家、怪物等等</li><li>对象是数据集合时，优先考虑结构体，比如位置、坐标等等</li><li>从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等等</li></ol><h2 id="成员变量和成员方法"><a href="#成员变量和成员方法" class="headerlink" title="成员变量和成员方法"></a>成员变量和成员方法</h2><ol><li><p>定义：用来描述类的属性或方法</p></li><li><p>声明：可以初始化，但在声明时和自己同类型的不能实例化</p></li><li><p>使用：必须在对象实例化后才可以使用</p></li><li><p>访问修饰符：</p></li></ol><table><thead><tr><th>访问修饰符</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>public</strong></td><td>所有人</td></tr><tr><td>internal</td><td>本项目</td></tr><tr><td>protected internal</td><td>本项目 + 子类</td></tr><tr><td><strong>protected</strong></td><td>类内部 + 子类</td></tr><tr><td><strong>private</strong></td><td>类内部</td></tr></tbody></table><ol start="5"><li><code>get</code>和<code>set</code>：</li></ol><ul><li>作用：保护成员变量，为成员属性的获取和赋值增加逻辑处理</li></ul><p>以下是实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Name的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 返回内容</span></span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line"><span class="comment">// value关键字：用于表示外部传入的值</span></span><br><span class="line">name = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>自动属性</li></ol><ul><li>定义：是<code>C#</code>提供的一种语法糖</li><li>特点：外部只能得不能改</li><li>写法：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 数据类型 属性名 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>定义：在实例化对象的时候用来<strong>初始化</strong>对象的函数，<strong>如果不写默认存在一个无参构造函数</strong></p><p>特点：</p><ol><li>写在<code>class</code>中，没有返回值</li><li>函数名和类名必须相同</li><li>一般是public</li><li>构造函数可以被重载：**this代表当前调用函数的对象</li></ol><p>以下是一个构造函数实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类的声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">pyblic <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">name = <span class="string">&quot;meimei&quot;</span>;</span><br><span class="line">age = <span class="number">19</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果写了有参构造函数，默认的无参构造函数会消失</strong></p><p>构造函数还有一种特殊写法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>): <span class="title">this</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的意思是先调用<code>Person</code>的无参构造函数，再进行有参构造函数。</p><h3 id="析构函数与GC-垃圾回收"><a href="#析构函数与GC-垃圾回收" class="headerlink" title="析构函数与GC 垃圾回收"></a>析构函数与GC 垃圾回收</h3><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>定义：回收引用类型的堆内存时调用的函数。</p><p>特点：不能<strong>手动调用</strong>。析构函数由 <strong>C# 的 GC 垃圾回收器</strong> 自动调用。</p><p>以下是一个析构函数的写法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~类名()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 释放资源、日志记录等收尾逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h4><p>过程：遍历堆(Heap)上动态分配的所有对象，若未被引用，则为垃圾GC管理堆，系统管理栈。</p><p>大概原理：默认分配内存在0代，0代满了有用的东西移到1代，0代未用空间释放，同理1代移向2代。</p><p>手动调用GC：<code>GC.Collect();</code>，在loading过场景时调用</p><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><ol><li><p>作用：让对象可以像数组一样通过下标访问其中元素。比较适用于有数组变量时使用。</p></li><li><p>语法：</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回值 <span class="keyword">this</span>[参数列表]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;&#125;</span><br><span class="line"><span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">private</span> Person[] friends;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引器</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> frinds[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// value 代表传入值</span></span><br><span class="line">friends[index] = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ol><li><p>作用：让自定义类和结构体能够使用运算符</p></li><li><p>关键字：<code>operator</code></p></li><li><p>语法：</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br></pre></td></tr></table></figure><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> +(Point p1, Point p2)</span><br><span class="line">&#123;</span><br><span class="line">Point p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = p1.x + p2.x;</span><br><span class="line">p.y = p1.y + p2.y;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>可重载的运算符：</li></ol><ul><li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>++</code>、<code>--</code></li><li>逻辑运算符：<code>!</code></li><li>位运算符：<code>|</code>、<code>&amp;</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>~</code></li><li>条件运算符：<code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code></li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><ol><li>定义：用<code>static</code>修饰的类，只能包含静态成员，不能被实例化，一般用于构造工具。</li></ol><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ol><li><p>定义：关键字<code>static</code>修饰的成员变量、方法、属性等</p></li><li><p>使用：<strong>直接用类名点出来使用，不用实例化。</strong> 在class里使用，静态成员与程序同生共死。<strong>改变时是用上一次他的值进行改变。</strong> 静态函数中不能使用非静态成员（实例化后才可以），非静态函数可以使用静态成员。</p></li><li><p>作用：</p></li></ol><ul><li>静态变量：<ul><li>常用唯一变量的申明（<code>PI</code>、重力加速度等）</li><li>方便获取对象的申明</li></ul></li><li>静态方法：<ul><li>常用的唯一方法的申明（数学计算相关函数）</li></ul></li></ul><ol start="4"><li>区分常量和静态变量：</li></ol><ul><li><code>const</code>(常量) 可以理解为特殊的<code>static</code>(静态)</li></ul><p><em>相同点</em><br>他们都可以通过类名点出使用<br><em>不同点</em></p><ul><li><code>const</code>必须初始化，不能修改，<code>static</code>没有这个规则</li><li><code>const</code>只能修饰变量，<code>static</code>可以修饰很多</li><li><code>const</code>一定是写在访问修饰符后面的，<code>static</code>没有这个要求</li></ul><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><ol><li><p>定义：在构造函数前加上<code>static</code>修饰</p></li><li><p>作用：在静态构造函数中初始化静态变量</p></li><li><p>特点：</p></li></ol><ul><li>静态类和普通类都可以有</li><li>不能使用访问修饰符</li><li>不能有参数</li><li>只会自动调用一次</li></ul><ol start="4"><li>使用：</li></ol><ul><li>静态类中的静态构造函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testInt = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testInt2 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">StaticClass</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">testInt = <span class="number">200</span>;</span><br><span class="line">testInt2 = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通类中的静态构造函数</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testInt = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol><li>使用条件：确保一个类在整个应用程序中<strong>只有一个实例</strong>。使用单例模式时会提供一个<strong>全局访问点</strong>来获取这个实例</li><li>作用：可以直接通过类名点出来使用，更快</li><li>两个关键的静态成员：<ul><li>私有的静态成员变量（用于声明）</li><li>公共的静态成员属性或者方法（用于获取）</li></ul></li></ol><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance =&gt; instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><ol><li>作用：为现有非静态变量类型添加新方法。写在静态类中，不继承<code>MonoBehaviour</code></li></ol><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Tools</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 第一个参数：拓展对象</span></span><br><span class="line"><span class="comment">// 第二个参数：参数类型 参数名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyLookAt</span>(<span class="params"><span class="keyword">this</span> Transform obj, Transform target</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li>定义：在一个类中在申明一个类，是亲密关系的表现</li><li>使用：要用包裹者点出自己，在外部使用加<code>public</code></li></ul><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Engine</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">Car.Engine carEngine = <span class="keyword">new</span> Car.Engine();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h3><ul><li>定义：把一个类分成几部分声明</li><li>作用：让代码更有可阅读性</li><li>关键字：<code>partial</code></li></ul><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>分部类可以写在多个脚本文件中</li><li>分部类的访问修饰符要一致</li><li>分部类中不能有重复成员</li></ol><p>类似的，也存在分部方法。分部方法只能在分部类中存在。</p><p>以下是关于分部方法的描述：</p><ul><li>作用：将方法的<strong>声明</strong>和<strong>实现</strong>分离，增加代码可读性</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分部类-部分1</span></span><br><span class="line">paetial <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分部方法-声明</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分部类-部分2</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分部方法-实现</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><strong>继承</strong>是指一个 <strong>类（子类、派生类）</strong> 可以获取另一个<strong>类（父类、基类、超类）</strong> 的<strong>属性</strong>和<strong>方法</strong>的机制。</p><p>继承的特点：</p><ol><li>单根性：子类只能有一个父类</li><li>传递性：子类可以间接继承父类的父类</li></ol><p>以下是继承的基本语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : 被继承的类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><ol><li><p>概念：任何父类出现的地方，子类都可以替代</p></li><li><p>语法表现：<strong>父类容器</strong>装<strong>子类对象</strong>，因为子类对象包含了父类的所有内容</p></li><li><p>作用：方便进行对象的存储和管理</p></li></ol><p>以下是里氏替换的一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：GameObject </span></span><br><span class="line"><span class="comment">// 子类：Player</span></span><br><span class="line">GameObject player = <span class="keyword">new</span> Player();</span><br></pre></td></tr></table></figure><h2 id="is-和-as"><a href="#is-和-as" class="headerlink" title="is 和 as"></a>is 和 as</h2><p><code>is</code>和<code>as</code>这两个关键字都与对象的<strong>类型判断</strong> &#x2F; <strong>类型转换</strong>有关，下面是详细的描述：</p><ul><li><code>is</code><ul><li>作用：判断一个对象是否是指定类对象</li><li>返回值：<code>bool</code> 是为真、不是为假</li><li>基本语法：<code>类对象 is 类名</code></li></ul></li><li><code>as</code><ul><li>作用：将一个对象转换为指定类对象</li><li>返回值：成功返回指定类型对象，失败返回<code>NULL</code></li><li>基本语法：<code>类对象 as 类名</code></li></ul></li></ul><p><code>is</code>和<code>as</code>常常配合使用，以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(player <span class="keyword">is</span> Player)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line"><span class="comment">// Player p = player as Player; 转换为对应类对象</span></span><br><span class="line"><span class="comment">// p.PlayerAtk(); 点出方法使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line">(player <span class="keyword">as</span> Player).PlayerAtk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><p>继承中的构造函数执行步骤是：</p><ul><li>先执行父类的构造函数</li><li>再执行子类的构造函数</li></ul><p>规则：子类实例化时默认调用父类<strong>无参构造函数</strong>，用<code>base</code>调用指定父类有参构造，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i</span>) : <span class="title">base</span>(<span class="params">i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="万物之父"><a href="#万物之父" class="headerlink" title="万物之父"></a>万物之父</h2><p><strong>万物之父</strong>即是<code>object</code>，<code>object</code>是所有类型的基类（引用类型）。</p><h3 id="万物之父的使用"><a href="#万物之父的使用" class="headerlink" title="万物之父的使用"></a>万物之父的使用</h3><p>他有这些作用：</p><ol><li>可以利用里氏替换原则，用<code>object</code>容器装所有对象</li><li>可以用来表示不确定类型，作为函数参数类型</li></ol><p>装<em>引用类型</em>变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">is</span> Son)</span><br><span class="line">&#123;</span><br><span class="line">(o <span class="keyword">as</span> Son).Speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装<em>值类型</em>变量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="number">1f</span>;</span><br><span class="line"><span class="comment">// 用强转</span></span><br><span class="line"><span class="built_in">float</span> f1 = (<span class="built_in">float</span>)o;</span><br></pre></td></tr></table></figure><p>装<em>string</em>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> str = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="built_in">string</span> str2 = str.ToString();</span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="built_in">string</span> str2 = str <span class="keyword">as</span> <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>装<em>数组</em>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="built_in">int</span>[] ar = arr <span class="keyword">as</span> <span class="built_in">int</span>[];</span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="built_in">int</span>[] ar = (<span class="built_in">int</span>[])arr;</span><br></pre></td></tr></table></figure><h3 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h3><p><strong>装箱</strong>指的是用<code>object</code>存值类型；<strong>拆箱</strong>指的是把<code>object</code>转为值类型。</p><p>运用<strong>装箱拆箱</strong>可以在不确定变量类型时方便参数的存储和传递，不过也会存在内存的迁移，增加性能消耗，所以尽量不要使用。</p><h3 id="万物之父中的方法"><a href="#万物之父中的方法" class="headerlink" title="万物之父中的方法"></a>万物之父中的方法</h3><ol><li>静态方法：</li></ol><ul><li><code>Equals</code>：判断两个对象是否相等<ul><li>值类型：比较数值</li><li>引用类型：比较内存地址</li></ul></li><li><code>ReferenceEquals</code>：比较两个对象是否是相同的引用<ul><li>值类型：始终是<code>false</code></li><li>引用类型：比较内存地址</li></ul></li></ul><ol start="2"><li>成员方法：</li></ol><ul><li><code>GetType</code>：获取对象运行时的类型<code>Type</code></li><li><code>Memberwiseclone</code>：返回一个新的对象，但是新对象中的引用变量会和老对象中一致</li></ul><ol start="3"><li>虚方法：</li></ol><ul><li><code>Equals</code>：相当于静态方法中的<code>ReferenceEquals</code></li><li><code>GetHashCode</code>：获取对象的哈希码</li><li><code>Tostring</code>：返回当前对象代表的字符串</li></ul><h2 id="密封类和密封方法"><a href="#密封类和密封方法" class="headerlink" title="密封类和密封方法"></a>密封类和密封方法</h2><p>定义：用<code>sealed</code>密封关键字修饰的类或方法<br>关键字：<code>sealed</code><br>作用：让类（方法）无法再被继承（重写）</p><p>密封方法往往和<code>override</code>一起出现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>所谓<strong>多态</strong>，是让继承同一父类的子类们在<strong>执行相同方法</strong>时<strong>有不同的表现</strong>，从而使同一个对象有唯一的行为特征。</p><h2 id="虚拟方法"><a href="#虚拟方法" class="headerlink" title="虚拟方法"></a>虚拟方法</h2><p>使用虚拟方法的目的是<strong>方便子类重写函数</strong>。</p><p>实现虚拟方法分为三个阶段：<br>V( virtual虚函数 ) -&gt; O( override重写 ) -&gt; B( base父类 )</p><p>下面是一个使用虚拟方法的例子：<br>首先，声明一个有虚函数的父类：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚函数 可以被子类重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 省略内部逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，用一个子类去重写其中的虚函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造函数,先执行父类的一个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">base</span>.Atk();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>base</code>代表父类，可以通过<code>base</code>来保留父类的行为。</p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p><strong>抽象方法</strong>和<strong>虚拟方法</strong>很像，抽象方法是一种特殊的虚拟方法。</p><p>它俩的<strong>区别</strong>主要是：<strong>虚函数</strong>是 <strong>“可选重写”</strong> 的多态函数，基类可实例化；<strong>抽象函数</strong>是 <strong>“强制重写”</strong> 的接口型函数，含抽象函数的类为抽象类，不可实例化。</p><p>接下来是一个抽象类和抽象方法的实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Thing</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （可选）在抽象类中写抽象方法</span></span><br><span class="line"><span class="comment">// 抽象方法中一定不能有函数体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> Fruits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>抽象类不能被实例化</li><li>继承抽象类必须用<code>override</code>重写其抽象方法</li><li>抽象方法 <em>只能在抽象类中声明</em> &amp;&amp; <em>没有方法体</em> &amp;&amp; <em>不能是私有的</em></li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol><li><p>定义：<strong>接口</strong>是行为的抽象规范（抽象<strong>行为</strong>的基类），是一种自定义类型。</p></li><li><p>关键字：<code>interface</code></p></li><li><p>语法：</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 接口名     **命名规范：帕斯卡前加一个<span class="title">I</span>**</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接口方法只用写定义，无方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口IFly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Fly</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承类Animal，接口IFly</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Animal</span>, <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Fly</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(name + <span class="string">&quot; is flying&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>接口不包含成员变量，只包含方法、属性、索引器、事件</li><li>类可以继承<code>1</code>个类，<code>n</code>个接口</li><li>继承接口后<strong>必须实现</strong>其中的内容且必须是<code>public</code>的</li><li>接口可以继承接口，不能继承类</li></ol><p>当一个类继承两个接口，但是两个接口中存在同名方法时，需要用到显式实现接口，语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名.行为名</span><br></pre></td></tr></table></figure><p>以下是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"><span class="built_in">string</span> p</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显式实现接口方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> IMyInerface.MyMethod(<span class="built_in">string</span> p)</span><br><span class="line">&#123;</span><br><span class="line">具体逻辑</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结性知识点"><a href="#总结性知识点" class="headerlink" title="总结性知识点"></a>总结性知识点</h1><h2 id="比较静态方法、成员方法、虚方法"><a href="#比较静态方法、成员方法、虚方法" class="headerlink" title="比较静态方法、成员方法、虚方法"></a>比较静态方法、成员方法、虚方法</h2><table><thead><tr><th>特性</th><th>静态方法</th><th>成员方法</th><th>虚方法</th></tr></thead><tbody><tr><td><strong>所属对象</strong></td><td><strong>类本身</strong></td><td>类的<strong>实例对象</strong></td><td>类的<strong>实例对象</strong></td></tr><tr><td>修饰关键字</td><td>必须加<code>static</code>（同时可加访问修饰符）</td><td>无（可加访问修饰符）</td><td>必须加 <code>virtual</code>（同时可加访问修饰符）</td></tr><tr><td><strong>调用方法</strong></td><td><code>类名.方法名</code></td><td><code>实例.方法名</code></td><td><code>实例.方法名</code></td></tr><tr><td><code>this</code>关键字</td><td>不存在（无实例，无法使用 <code>this</code>）</td><td>存在</td><td>存在</td></tr><tr><td>成员访问权限</td><td>仅可访问<strong>静态成员</strong>，无法访问实例成员</td><td>可访问<strong>实例成员</strong>和<strong>静态成员</strong></td><td>可访问<strong>实例成员</strong>和<strong>静态成员</strong></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">C#是游戏开发（尤其Unity生态）的主流语言，其对面向对象（OOP）思想的完美适配是核心原因之一。本文结合游戏开发场景，梳理C#面向对象的封装、继承、多态核心特性，是学习C#面向对象的实战型笔记。</summary>
    
    
    
    <category term="高级编程语言/C#" scheme="http://tymblog.yuzhiboliuhua.cn/categories/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/"/>
    
    
    <category term="CSharp" scheme="http://tymblog.yuzhiboliuhua.cn/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>存档系统之数据持久化</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/9b82fc53.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/9b82fc53.html</id>
    <published>2025-11-07T09:41:00.000Z</published>
    <updated>2026-02-14T08:35:44.707Z</updated>
    
    <content type="html"><![CDATA[<p>游戏运行时，我们的游戏数据都是存在<strong>内存</strong>中的，一旦退出游戏，内存将被释放，这时游戏数据并没有保留下来。因此，利用<strong>数据持久化</strong>的操作可以将游戏数据从<strong>内存</strong>存储到<strong>硬盘</strong>中，从而实现游戏数据的保存。</p><p>这篇文章将会介绍几种数据持久化的方案。</p><p>值得一提的是，独立开发游戏一般选择<code>Json</code>，优点是<strong>人类可读</strong>，<strong>易调试</strong>；而大型联机游戏一般选择<em>二进制存储</em>，人类虽然不可读不易调试，但是它的<strong>解析速度最快</strong>，<strong>也更安全</strong>。</p><hr><h1 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h1><p><code>PlayerPrefs</code>是<code>Unity</code>官方封装好的<strong>键值对</strong>本地存储工具<strong>类</strong>。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>键：<code>string</code><br>值：<code>int</code>、<code>float</code>、<code>string</code></p><p><code>PlayerPrefs</code>的存储方式是用类名<code>PlayerPrefs.Setxxx</code>来实现，其中<code>xxx</code>中填入要存储的值类型，参数依次传入<strong>键名</strong>、<strong>要存储的值</strong>。下面是用<code>PlayerPrefs</code>存储的几个例子：</p><ul><li>存储<code>int</code>型到内存中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(“myAge”, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><ul><li>存储<code>float</code>型到内存中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetFloat(“myHeight”, <span class="number">165.5f</span>);</span><br></pre></td></tr></table></figure><ul><li>存储<code>string</code>型到内存中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetString(“myName”, <span class="string">&quot;大鱼飞九草&quot;</span>);</span><br></pre></td></tr></table></figure><p>当游戏结束时，<code>Unity</code>会<strong>自动</strong>把数据存在<strong>硬盘</strong>中。如果游戏不是正常结束而是崩溃，数据是不会存到硬盘中的。因此，可以调用这个方法立马存储到硬盘中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.Save();</span><br></pre></td></tr></table></figure><p>另外，<code>PlayerPrefs</code>有一定的局限性，因为只存在三种类型的存储方式，因此，在存储其他数据时会降低精度。</p><p><strong>注意：</strong></p><ul><li>用同一键名存储的值会被覆盖</li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取的顺序是先从内存找，再到硬盘中找。</p><p><code>PlayerPrefs</code>的读取方式是用类名<code>PlayerPrefs.Getxxx</code>来实现，其中<code>xxx</code>中填入要读取的值类型，参数传入<strong>键名</strong>。下面是用<code>PlayerPrefs</code>读取的例子：</p><ul><li>读取<code>int</code>类型</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = PlayerPrefs.GetInt(<span class="string">&quot;myAge&quot;</span>);</span><br></pre></td></tr></table></figure><p>还有一种重载：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数2：默认值</span></span><br><span class="line">age = PlayerPrefs.GetInt(<span class="string">&quot;myAge&quot;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>第二个参数默认值对于我们的作用：在得到没有的数据的时候，可以用它来进行<strong>基础数据的初始化</strong>。</p><p>读取<code>float</code>、<code>string</code>类型的也都相似。</p><p>注意：当里面没有值时，会返回一个默认值。<code>int</code>对应<code>0</code>，<code>float</code>对应<code>0</code>，<code>string</code>对应<code>&quot;&quot;</code>。</p><h3 id="判断键是否存在"><a href="#判断键是否存在" class="headerlink" title="判断键是否存在"></a>判断键是否存在</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(PlayerPrefs.HasKey(<span class="string">&quot;myName&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>删除指定键值对</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;myKey&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>删除所有存储的信息</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.DeleteAll();</span><br></pre></td></tr></table></figure><h2 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h2><p>不同平台<code>PlayerPrefs</code>的存储位置不一样。</p><ul><li><code>Windows</code><ul><li>位置：<code>HKCU\SoftWare\[公司名称]\[产品名称]</code>项下的注册表中</li></ul></li><li><code>Android</code><ul><li>位置：<code>/data/data/包名/shared_prefs/包名.xml</code></li></ul></li><li><code>IOS</code><ul><li>位置：<code>/Library/Preferences/[应用ID].plist</code></li></ul></li></ul><hr><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><code>XML</code>是一种特殊格式的<strong>文件</strong>，用于传输和存储数据 。<code>XML</code>是一种树形结构根节点。</p><h2 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h2><ol><li><p>创建XML文件：把后缀名改为<code>.xml</code></p></li><li><p>注释：</p></li></ol><ul><li>单行注释</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在其中书写注释相关内容 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>固定内容：一定要写在第一行</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- version代表版本 encoding代表编码格式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 编码格式：ASCII码 与 UTF-8 就是两种不同的编码格式 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding = <span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>基本语法</li></ol><p><code>xml</code>的基本语法是<code>&lt;元素标签&gt; &lt;/元素标签&gt;</code>配对出现。可以理解为<strong>树形结构</strong>：必须要<strong>有且仅有一个</strong>根节点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PlayerInfo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>meimei酱<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>false<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ItemList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">num</span>&gt;</span>10<span class="tag">&lt;/<span class="name">num</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">num</span>&gt;</span>20<span class="tag">&lt;/<span class="name">num</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemList</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PlayerInfo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：特殊符号在xml中的写法</strong></p><table><thead><tr><th>符号</th><th>xml中写作</th></tr></thead><tbody><tr><td>&lt;</td><td><code>&amp;lt</code></td></tr><tr><td>&gt;</td><td><code>&amp;gt</code></td></tr><tr><td>&amp;</td><td><code>&amp;amp</code></td></tr><tr><td>‘</td><td><code>&amp;apos</code></td></tr><tr><td>‘’</td><td><code>&amp;quot</code></td></tr></tbody></table><h3 id="XML属性"><a href="#XML属性" class="headerlink" title="XML属性"></a>XML属性</h3><p><strong>区别属性和元素：</strong> </p><ul><li>元素：一个节点之中包裹的东西，即<code>&lt;&gt;元素&lt;/&gt;</code></li><li>属性：写在节点内部的东西，即<code>&lt;Friend 属性&gt;</code></li></ul><p>它俩表示的意思一样，只是两种写法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性必须用引号包裹 单引号双引号都可以 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Friend</span> <span class="attr">name</span> = <span class="string">&quot;小明&quot;</span> <span class="attr">age</span> = <span class="string">&#x27;8&#x27;</span>&gt;</span>我的朋友<span class="tag">&lt;/<span class="name">Friend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用属性记录信息，不想使用元素记录，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Frind</span> <span class="attr">name</span> = <span class="string">&quot;小明&quot;</span> <span class="attr">age</span> = <span class="string">&quot;8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="验证是否有错"><a href="#验证是否有错" class="headerlink" title="验证是否有错"></a>验证是否有错</h3><p>复制到该网址验证：<br><a href="https://www.runoob.com/xml/xml-validator.html">xml - 菜鸟教程</a></p><h2 id="C-读取存储Xml"><a href="#C-读取存储Xml" class="headerlink" title="C#读取存储Xml"></a>C#读取存储Xml</h2><ol><li><p>Xml文件存放的位置：</p><ul><li>只读不写：<code>Resource / StreamingAssets</code> 文件夹下</li><li>动态存储：<code>Application.persistentDataPath</code> 路径下</li></ul></li><li><p>读取方法：</p><ul><li><code>XmlDocument</code>（较方便且容易操作）</li><li><code>XmlTextReader</code></li><li><code>Linq</code></li></ul></li></ol><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><h4 id="读取Xml文件信息"><a href="#读取Xml文件信息" class="headerlink" title="读取Xml文件信息"></a>读取Xml文件信息</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Xml; <span class="comment">// 需要引用的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建文本对象</span></span><br><span class="line">XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接根据xml字符串内容 来加载xml文件</span></span><br><span class="line"><span class="comment">// 存放在Resources文件夹下的xml文件加载处理（TestXml是一个在Resources里的xml文件）</span></span><br><span class="line">TextAsset asset = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;TestXml&quot;</span>);</span><br><span class="line">xml.LoadXml(asset.text);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过xml文件的路径去进行加载（TestXml是一个在StreamAssets里的xml文件）</span></span><br><span class="line">xml.Load(Application.streamingAssetsPath + <span class="string">&quot;/TestXml.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="读取元素和属性信息"><a href="#读取元素和属性信息" class="headerlink" title="读取元素和属性信息"></a>读取元素和属性信息</h4><ol><li>关键的两个类：</li></ol><ul><li>节点信息类（单个） <code>XmlNode</code></li><li>节点列表信息类（多个）<code>XmlNodeList</code></li></ul><ol start="2"><li>读取元素：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取xml当中的根节点 参数：固定为&quot;Root&quot;</span></span><br><span class="line">XmlNode root = xml.SelectSingleNode(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 在通过根节点 去获取下面的子节点 参数：要获取的节点的内容的字符串</span></span><br><span class="line">XmlNode nodeName = root.SelectSingleNode(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 3. 获取节点包裹的元素信息，直接.InnerText</span></span><br><span class="line">nodeName.InnerText</span><br></pre></td></tr></table></figure><ol start="3"><li>读取属性：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过根节点 去获取下面的子节点</span></span><br><span class="line">XmlNode nodeItem = root.SelectSingleNode(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 通过这个节点得到里面的属性 </span></span><br><span class="line"><span class="comment">// 方式1：通过[]得到 []里写的是键</span></span><br><span class="line">nodeItem.Attributes[<span class="string">&quot;id&quot;</span>].Value;</span><br><span class="line"><span class="comment">// 方式2：通过 GetNameItem() 得到</span></span><br><span class="line">nodeItem.Attributes.GetNameItem(<span class="string">&quot;id&quot;</span>).Value</span><br></pre></td></tr></table></figure><p><strong>注意：如果要得到一个同名节点的信息，不要通过XmlNode，这样只能得到第一个节点</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 得到信息</span></span><br><span class="line">XmlNodeList friendLit = root.SlectNodes(<span class="string">&quot;Friend&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 遍历</span></span><br><span class="line"><span class="comment">// 方式一：迭代器遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(XmlNode item <span class="keyword">in</span> friendList)</span><br><span class="line">&#123;</span><br><span class="line">print(item.SelectSingleNode(<span class="string">&quot;name&quot;</span>).InnerText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; friendList.Count; i ++)</span><br><span class="line">&#123;</span><br><span class="line">print(friendList[i].SelectSingleNode(<span class="string">&quot;name&quot;</span>).InnerText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h3><ol><li>存储路径：<code>Application.persistentDataPath</code></li><li>关键类：</li></ol><ul><li><code>XmlDocument</code> 用于创建节点 存储文件</li><li><code>XmlDeclaration</code> 用于添加版本信息</li><li><code>XmlElement</code> 节点类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Xml;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0. 准备存储路径</span></span><br><span class="line"><span class="built_in">string</span> path = Application.persistentDataPath + <span class="string">&quot;/PlayerInfo2.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建文本对象</span></span><br><span class="line">XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加固定版本信息</span></span><br><span class="line"><span class="comment">// 参数1：版本号</span></span><br><span class="line"><span class="comment">// 参数2：编码格式</span></span><br><span class="line"><span class="comment">// 参数3：只用传一个空字符串</span></span><br><span class="line">XmlDeclaration xmlDec = xml.CreateXmlDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 创建完成后 要添加进 文本对象中</span></span><br><span class="line">xml.AppendChild(xmlDec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加根节点</span></span><br><span class="line">XmlElement root = xml.CreateElement(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line">xml.AppendChild(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.添加子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1 为根节点添加子节点</span></span><br><span class="line">XmlElement name = xml.CreateElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">name.InnerText = <span class="string">&quot;小明&quot;</span>;                                 </span><br><span class="line">root.AppendChild(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2 为子节点添加子节点</span></span><br><span class="line">XmlElement listInt = xml.CreateElement(<span class="string">&quot;listInt&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">XmlElement childNode = xml.CreateElement(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">childNode.InnerText = i.ToString();</span><br><span class="line">listInt.AppendChild(childNode);</span><br><span class="line">&#125;</span><br><span class="line">root.AppendChild(listInt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.3 添加属性</span></span><br><span class="line">XmlElement itemList = xml.CreateElement(<span class="string">&quot;itemList&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i = <span class="number">3</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">XmlElement childNode = xml.CreateElement(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">childNode.SetAttribute(<span class="string">&quot;id&quot;</span>, i.ToString());</span><br><span class="line">itemList.AppendChild(childNode);</span><br><span class="line">&#125;</span><br><span class="line">root.AppendChild(itemList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 保存</span></span><br><span class="line">xml.Save(path);</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先判断是否存在文件</span></span><br><span class="line"><span class="keyword">if</span>( File.Exists(path) ) <span class="comment">// File是自带的类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2. 加载后 直接添加节点 移除节点即可</span></span><br><span class="line">XmlDocument newXml = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">newXml.Load(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改就是在原有的基础上 移除或者添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="comment">// 写法1:</span></span><br><span class="line">XmlNode node = newXml.SelectStingleNode(<span class="string">&quot;Root&quot;</span>).SelectStingleNode(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 写法2：</span></span><br><span class="line">XmlNode node = newXml.SelectStingleNode(<span class="string">&quot;Root/name&quot;</span>);</span><br><span class="line"><span class="comment">// 移除子节点</span></span><br><span class="line">XmlNode root2 = newXml.SelectSingleNode(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line">root2.RemoveChild(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">XmlElement speed = newXml.CreateElement(<span class="string">&quot;moveSpeed&quot;</span>);</span><br><span class="line">speed.InnerText = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">root2.AppendChild(speed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改了记得存</span></span><br><span class="line">newXml.Save(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML序列化与反序列化"><a href="#XML序列化与反序列化" class="headerlink" title="XML序列化与反序列化"></a>XML序列化与反序列化</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><strong>序列化</strong>是把<strong>内存中的数据</strong>存储到<strong>硬盘</strong>的过程</p><ol><li>几个关键类：</li></ol><ul><li><code>XmlSerializer</code> 用于序列化对象为<code>xml</code></li><li><code>StreamWriter</code> 用于存储文件</li><li><code>using</code> 用于方便流对象释放和销毁</li></ul><ol start="2"><li>序列化</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO; <span class="comment">// 使用 StreamWriter 时要引用的命名空间</span></span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lesson1Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这是我想要保存的类对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 准备一个想要保存的类</span></span><br><span class="line">Lesson1Test lt = <span class="keyword">new</span> Lesson1Test();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 序列化</span></span><br><span class="line"><span class="comment">// 2.1 确定存储路径</span></span><br><span class="line"><span class="built_in">string</span> path = Application.persistentDataPath + <span class="string">&quot;/Test.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 写入文件</span></span><br><span class="line"><span class="comment">// 括号内的代码：写入一个文件流，如果有该文件直接打开并修改，如果没有直接新建</span></span><br><span class="line"><span class="comment">// using 的新用法：括号当中包裹的声明的对象 会在 大括号语句块结束后自动释放</span></span><br><span class="line"><span class="keyword">using</span> ( StreamWriter stream = <span class="keyword">new</span> StreamWriter(path) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 声明一个序列化翻译器</span></span><br><span class="line">XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Lesson1Test));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Serialize方法进行序列化翻译</span></span><br><span class="line"><span class="comment">// 参数1：文件流对象</span></span><br><span class="line"><span class="comment">// 参数2：想要被翻译的对象</span></span><br><span class="line"><span class="comment">// 注意：翻译机器的类型要和传入的对象是一致的</span></span><br><span class="line">s.Serialize(stream, lt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：序列化只支持<code>public</code>，不支持字典</strong></p><ol start="3"><li><p>以属性方式存储：<br>加上一个特性：<code>[XmlAttribute()]</code> ，括号里面可以传想要的属性名（字符串形式）</p></li><li><p>给元素改名字：</p></li></ol><ul><li>普通元素：<code>[XmlElement()]</code></li><li>List：<code>[XmlArray()]</code></li><li>List里面的元素：<code>[XmlArrayItem()]</code></li></ul><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><strong>反序列化</strong>是把<strong>硬盘数据</strong>还原为<strong>内存上数据</strong>的过程</p><ol><li>反序列化：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.写出要反序列化对象所在路径</span></span><br><span class="line"><span class="built_in">string</span> path = Application.persistentDataPath + <span class="string">&quot;/Lesson1Test.xml&quot;</span>;</span><br><span class="line"><span class="comment">// 1. 判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span>( File.Exists(path) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2. 反序列化</span></span><br><span class="line"><span class="comment">// 2.1 读取文件</span></span><br><span class="line"><span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(path))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 声明一个反序列化翻译器</span></span><br><span class="line">XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Lesson1Test));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过DeSerialize方法进行反序列化翻译</span></span><br><span class="line"><span class="comment">// 参数：想要反序列化的对象</span></span><br><span class="line">Lesson1Test lt = s.DeSerialize(reader) <span class="keyword">as</span> Lesson1Test;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：List对象如果有默认值，反序列化时不会清空，会在后面添加</strong></p><h3 id="Ixmlserializable-接口"><a href="#Ixmlserializable-接口" class="headerlink" title="Ixmlserializable 接口"></a>Ixmlserializable 接口</h3><ol><li><p>定义：<code>Ixmlserializable</code>是<code>XmlSerializer</code>提供的可拓展内容。他能让一些不能被序列化和反序列化的特殊类能被处理。</p></li><li><p>自定义类实践：</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test1</span> : <span class="title">Ixmlserializable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是实现这个接口后要实现的方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlSchema <span class="title">GetSchema</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadXml</span>(<span class="params">XmlReader reader</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 反序列化时自动调用</span></span><br><span class="line"><span class="comment">// 1. 读属性</span></span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="built_in">int</span>.Parse(reader[<span class="string">&quot;test1&quot;</span>]);</span><br><span class="line"><span class="comment">// 2. 读节点</span></span><br><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line">reader.Read(); <span class="comment">// 这时是读到根节点</span></span><br><span class="line">reader.Read(); <span class="comment">// 这时是读到test1前面包裹节点</span></span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="built_in">int</span>.Parse(reaser.Value()); <span class="comment">// 得到当前内容的值</span></span><br><span class="line">reader.Read(); <span class="comment">// 这时是读到test1尾部包裹节点</span></span><br><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="keyword">while</span>( reader.Read() )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( reader.NodeType == XmlNodeType.Element )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(reader.Name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;test1&quot;</span>:</span><br><span class="line">reader.Read();</span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="built_in">int</span>.Parse(reader.Value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 读包裹元素节点</span></span><br><span class="line">XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line"><span class="comment">// 跳过根节点</span></span><br><span class="line">reader.Read();</span><br><span class="line">reader.ReadStartElement(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">test1 = (<span class="built_in">int</span>)s.Deserialize(reader);</span><br><span class="line">reader.ReadEndElement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteXml</span>(<span class="params">XmlWriter writer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 序列化时自动调用</span></span><br><span class="line"><span class="comment">// 1. 写属性</span></span><br><span class="line">writer.WriteAttributeString(<span class="string">&quot;test1&quot;</span>, <span class="keyword">this</span>.test1.toString());</span><br><span class="line"><span class="comment">// 2. 写节点</span></span><br><span class="line">writer.WriteElementString(<span class="string">&quot;test1&quot;</span>, <span class="keyword">this</span>.test1.toString());</span><br><span class="line"><span class="comment">// 3. 写包裹节点</span></span><br><span class="line">Xmlserializer s = <span class="keyword">new</span> Xmlserializer(<span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">writer.WriteStartElement(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">s.Serialize(writer, test1);</span><br><span class="line">writer.WriteEndElement();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line"><span class="comment">// 省略序列化和反序列化内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让Dictionary支持序列化"><a href="#让Dictionary支持序列化" class="headerlink" title="让Dictionary支持序列化"></a>让Dictionary支持序列化</h3><p>思路：继承<code>Dictionary</code>，然后实现<code>Ixmlserializable</code>接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerializerDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; : <span class="title">Dictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;, <span class="title">Ixmlserializable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlSchema <span class="title">GetSchema</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadXml</span>(<span class="params">XmlReader reader</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">XmlSerializer keySer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(TKey));</span><br><span class="line">XmlSerializer ValueSer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(TValue));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过根节点</span></span><br><span class="line">reader.Read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(reader.NodeType != XmlNodeType.EndElemenrt)</span><br><span class="line">&#123;</span><br><span class="line">TKey key = (TKey)keySer.Deserialize(reader);</span><br><span class="line">TValue <span class="keyword">value</span> = (TValue)keySer.Deserialize(reader);</span><br><span class="line"><span class="keyword">this</span>.Add(key, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteXml</span>(<span class="params">XmlWriter writer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">XmlSerializer keySer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(TKey));</span><br><span class="line">XmlSerializer ValueSer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(TValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(KeyValuePair&lt;TKey, TValue&gt; kv <span class="keyword">in</span> <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 键值对的序列化</span></span><br><span class="line">keySer.Serialize(writer, kv.Key);</span><br><span class="line">ValueSer.Serialize(writer, kv.Value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span>: <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">TestLesson4 tl4 = <span class="keyword">new</span> TestLesso4()</span><br><span class="line">tl4.dic = <span class="keyword">new</span> SerializerDictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="comment">// 省略序列化和反序列化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><p><code>Json</code>是一种特殊的文件格式，主要用于<strong>传输数据</strong>、本地数据<strong>存储</strong>和<strong>读取</strong>。<br>与<code>xml</code>的区别是<code>Json</code>配置更简单、某些情况下读写更快速。</p><h2 id="Json基本语法"><a href="#Json基本语法" class="headerlink" title="Json基本语法"></a>Json基本语法</h2><ol><li><p>创建Json文件：把后缀名改为<code>.json</code></p></li><li><p>注释：</p></li></ol><ul><li>单行注释</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释内容</span></span><br></pre></td></tr></table></figure><ul><li>多行注释</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>基本语法：</li></ol><p><code>Json</code>格式是一种<strong>键值对结构</strong>。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>&#123;&#125;</code></td><td>对象</td></tr><tr><td><code>[]</code></td><td>数组</td></tr><tr><td><code>:</code></td><td>键值对 对应关系</td></tr><tr><td><code>,</code></td><td>数据分割</td></tr><tr><td><code>&quot;&quot;</code></td><td>键名、字符串</td></tr></tbody></table><p>键值对表示：<code>&quot;键名&quot; : 值内容</code>，其中，值可以是数字、字符串、<code>bool</code>值、数组、对象、<code>null</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大括号 包裹的就代表一个对象</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">// 冒号 代表 键值对的对应关系</span></span><br><span class="line"><span class="comment">// 逗号 代表 成员变量的间隔符</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;meimei酱&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="number">165.5</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 中括号 代表 数组</span></span><br><span class="line"><span class="attr">&quot;ids&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;students&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;玛丽亚&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;小明&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span> <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;home&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;成都&quot;</span><span class="punctuation">,</span><span class="attr">&quot;street&quot;</span><span class="punctuation">:</span><span class="string">&quot;春熙路&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;son&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在线转Json网站：<code>bejson</code></p><h2 id="C-读取存储Json"><a href="#C-读取存储Json" class="headerlink" title="C#读取存储Json"></a>C#读取存储Json</h2><h3 id="存读字符串"><a href="#存读字符串" class="headerlink" title="存读字符串"></a>存读字符串</h3><ul><li><strong>存储</strong>字符串到指定路径文件中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="comment">// 参数1：要存储的路径</span></span><br><span class="line"><span class="comment">// 参数2：要存储的字符串内容</span></span><br><span class="line">File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Test.json&quot;</span>, <span class="string">&quot;小草存储的json文件&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：直接写文件名和后缀，不能自己加一个文件夹</strong></p><ul><li>在指定的路径文件中<strong>读取</strong>字符串</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="comment">// 参数：要读取的路径</span></span><br><span class="line"><span class="built_in">string</span> str = File.ReadAllText(Application.persistentDataPath + <span class="string">&quot;/Test.json&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h3><p><code>Jsonutility</code>是<code>Unity</code>自带的用于解析<code>Json</code>的<strong>公共类</strong>。它可以将内存中的对象序列化为<code>Json</code>格式的字符串，也可以将<code>Json</code>字符串反序列化为类对象。</p><ul><li>序列化：内存 -&gt; 硬盘</li></ul><p><code>JsonUtility</code>提供了现成的方法，可以把<strong>类对象</strong>序列化为 <strong><code>json</code>字符串</strong>，下面是一个实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 存储类中成员略</span></span><br><span class="line"><span class="built_in">string</span> jsonStr = JsonUtility.ToJson(p);</span><br><span class="line">File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Person.json&quot;</span>, jsonStr);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>float</code>序列化时看起来会有一些误差，不过读出时不影响。</li><li><strong>自定义类</strong>需要加上序列化特性<code>[System.Serializable]</code></li><li>想要序列化私有变量，需要加上特性<code>[SerializeField]</code></li><li><code>JsonUtility</code>不支持字典</li><li>存储<code>null</code>时会有一个默认值</li></ol><ul><li>反序列化：硬盘 -&gt; 内存</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="comment">// 读取文件中的json字符串</span></span><br><span class="line">jsonStr = File.ReadAllText(Application.persistentDataPath + <span class="string">&quot;/Person.json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用json字符串内容 转换为类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="comment">// 参数1：要读取的json文件</span></span><br><span class="line"><span class="comment">// 参数2：json文件中对应的类的类型</span></span><br><span class="line">Person p = JsonUtility.FromJson(jsonStr, <span class="keyword">typeof</span>(Person)) <span class="keyword">as</span> Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="comment">// 参数：要读取的json文件</span></span><br><span class="line">Person p1 = JsonUtility.FromJson&lt;Person&gt;(jsonStr);</span><br></pre></td></tr></table></figure><p><strong>注意：如果<code>json</code>中数据少了，不会报错</strong></p><p>另外，<code>JsonUtility</code>无法直接读取数据集合，需要用类对象包裹一层，编码格式必须是<code>UTF-8</code></p><h3 id="LitJson"><a href="#LitJson" class="headerlink" title="LitJson"></a>LitJson</h3><p><code>LitJson</code>是一个<strong>第三方库</strong>，用于处理<code>Json</code>的序列化和反序列化。它体积小、速度快、易于使用，使用时只需要把他的代码拷贝到工程中即可。建议使用<code>LitJson</code>。</p><ul><li><p>获取：直接浏览器搜索<code>LitJson</code> -&gt; 官网中访问<code>GitHUb</code> -&gt; 右侧<code>release</code>下载最新版本 -&gt; 拷贝<code>src/Litjson</code>放进<code>sript</code>文件夹（可以删除除了<code>cs</code>文件外的其他文件）</p></li><li><p>序列化</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line">Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">// 存储类中成员略</span></span><br><span class="line"><span class="built_in">string</span> jsonStr = JsonMapper.ToJson(a);</span><br><span class="line">File.WriteAllText(Application.persistentDataPath + <span class="string">&quot;/Animal.json&quot;</span>, jsonStr);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>通过<code>LitJson</code>存储的字符串表现上有点不一样，不过反序列化回来不影响</li><li>可以存储字典，字典的键建议用字符串</li><li>不能序列化私有变量</li><li>需要引用<code>LitJson</code>命名空间</li><li>能够准确的存储<code>null</code></li></ol><ul><li>反序列化</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line">jsonStr = File.ReadAllText(Application.persistentDataPath + <span class="string">&quot;/Animal.json&quot;</span>);</span><br><span class="line"><span class="comment">// JsonData是LitJson提供的类对象，可以用键值对的形式去访问其中的内容</span></span><br><span class="line">jsonData data = jsonMapper.ToObject(jsonStr);</span><br><span class="line"><span class="comment">// 方法一：索引器里面填类对象的成员变量名</span></span><br><span class="line">print(data[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line"><span class="comment">// 方法二：泛型方法</span></span><br><span class="line">Animal a = JsonMapper.ToObject&lt;Animal&gt;(jsonStr);</span><br><span class="line">print(a.name);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>虽然支持字典类型，但是键一定是字符串类型才能使用。</li><li>类结构需要<strong>无参构造函数</strong>，否则反序列化的时候会报错。</li></ol><p>与<code>JsonUtility</code>不同的是，<code>LitJson</code>可以直接读取数据集合。相同点是文本编码格式是<code>UTF-8</code></p><h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>（未完待续）</p>]]></content>
    
    
    <summary type="html">临时储存在内存中的数据如何保存在本地呢？如何实现游戏中的存档操作？这篇文章将会记录关于数据持久化的内容。</summary>
    
    
    
    <category term="Unity/数据持久化" scheme="http://tymblog.yuzhiboliuhua.cn/categories/Unity-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
    <category term="#数据持久化" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity之物理系统</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/e1e8becf.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/e1e8becf.html</id>
    <published>2025-11-04T06:58:00.000Z</published>
    <updated>2026-02-15T12:15:00.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><p><strong>碰撞产生的条件：两个物体都有碰撞器，至少一个物体有刚体</strong><br>碰撞器：用来表现一个3D物体的体积<br>刚体：用来受到力的效果<br><strong>作用：</strong> 实体物体之间产生物理效果</p><h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><p>物理材质是用于决定物体产生碰撞时，这些物体之间的摩擦和弹性表现的。</p><h3 id="创建物理材质"><a href="#创建物理材质" class="headerlink" title="创建物理材质"></a>创建物理材质</h3><p>Project右键 -&gt; Creat -&gt; Physic Material &#x2F; Physic Material 2D</p><h3 id="物理材质的参数"><a href="#物理材质的参数" class="headerlink" title="物理材质的参数"></a>物理材质的参数</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>滑动摩擦力（Dynamic Friction）</td><td>值越大摩擦力越大</td></tr><tr><td>静摩擦力（Static Friction）</td><td>值越大摩擦力越大</td></tr><tr><td>弹性（Bounciness）</td><td>值为0不会反弹，1反弹时不产生任何能量损失</td></tr><tr><td>摩擦力组合方式（Friction Combine）</td><td>Average：对两个摩擦力求平均值。&#x2F;  Minimun：使用两个值中的最小值。 &#x2F;  Maxmum：使用两个值中的最大值。&#x2F;  Multiply：两个摩擦值相乘。</td></tr></tbody></table><h2 id="物理碰撞"><a href="#物理碰撞" class="headerlink" title="物理碰撞"></a>物理碰撞</h2><h3 id="Collider碰撞器组件"><a href="#Collider碰撞器组件" class="headerlink" title="Collider碰撞器组件"></a>Collider碰撞器组件</h3><p>碰撞器是用于在物理系统中表示物体体积的（形状或范围），刚体通过得到碰撞器的范围信息进行计算，判断两个物体的范围是否接触，如果接触，就会模拟力的效果产生速度和旋转。</p><h4 id="碰撞器种类"><a href="#碰撞器种类" class="headerlink" title="碰撞器种类"></a>碰撞器种类</h4><ol><li>3D碰撞器</li></ol><ul><li><strong>盒状</strong></li><li><strong>球状</strong></li><li><strong>胶囊</strong></li><li>网格：Mesh Collider，加了刚体的碰撞器必须勾选<code>Convex</code>才能受到力的作用</li><li>轮胎：Wheel Collider</li><li>地形：Terrain Collider</li></ul><p><strong>注：</strong> 没加粗的三种碰撞器性能消耗较高，但比较准确。</p><ol start="2"><li>2D碰撞器</li></ol><ul><li><strong>圆形碰撞器</strong></li><li><strong>盒状碰撞器</strong></li><li><strong>多边形碰撞器</strong></li><li><strong>边界碰撞器</strong></li><li>胶囊碰撞器</li><li>复合碰撞器</li></ul><h4 id="共同参数"><a href="#共同参数" class="headerlink" title="共同参数"></a>共同参数</h4><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><strong>是否是触发器（Is Trigger）</strong></td><td><strong>勾选即被物理引擎忽略，用于无物理效果的碰撞检测</strong></td></tr><tr><td>物理材质（Material）</td><td>可以确定碰撞体和其他对象碰撞时的表现方式（摩擦、弹性）</td></tr><tr><td>中心点（Center）</td><td>碰撞体在对象局部空间中的中心点位置</td></tr></tbody></table><h4 id="特有参数"><a href="#特有参数" class="headerlink" title="特有参数"></a>特有参数</h4><p>3D碰撞器：</p><table><thead><tr><th>碰撞器种类</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>盒状碰撞器（Box Collider）</td><td>大小（Size）</td><td>碰撞体在X、Y、Z方向上的大小</td></tr><tr><td>球状碰撞器（Sphere Collider）</td><td>半径（Radius）</td><td>球形碰撞器的半径大小</td></tr><tr><td>胶囊碰撞器（Capsule Collider）</td><td>半径（Radius）&#x2F;  高度（Height）&#x2F;  轴向（Direction）</td><td>胶囊体的半径 &#x2F; 高度 &#x2F; 在局部空间中的轴向</td></tr></tbody></table><p><strong>注：</strong> 异形物体使用多种碰撞器组合，刚体对象的子对象碰撞器信息参与碰撞检测。<br>例如，要创建一个汽车（<strong>质量一定要足够大 1500kg</strong>）：</p><p><img src="https://tymimg.yuzhiboliuhua.cn/PhysicalSystem/Car.png" alt="Car.png (204×115)"></p><p>2D碰撞器：</p><table><thead><tr><th>碰撞器种类</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>圆形碰撞器（Circle Collider 2D）</td><td>半径（Radius）&#x2F;  圆心偏移位置（Offset）&#x2F;  是否被附加的2D效应器使用（Used By Effector）</td><td>圆形碰撞器的半径大小 &#x2F; 圆心偏移位置 &#x2F; 被附加的2D效应器使用</td></tr><tr><td>盒状碰撞器（Box Collider 2D）</td><td>大小（Size）&#x2F;  是否附加到2D符合碰撞器（Used by Composite）&#x2F;  自动改变尺寸（Auto Tiling）&#x2F;  边缘半径（Edge Radius）</td><td>碰撞体在X、Y、Z方向上的大小 &#x2F; 附加到2D符合碰撞器 &#x2F; 如果精灵渲染器组件的Draw Mode设置为Tiled平铺模式，勾选后，当改变精灵大小时将自动更新碰撞器的尺寸 &#x2F; 使四个顶点为圆角</td></tr><tr><td>多边形碰撞器（Polygon Collider 2D）</td><td>多边形顶点（Points）</td><td><strong>一般用Edit Collider编辑</strong></td></tr><tr><td>边界碰撞器（Edge Collider 2D）</td><td></td><td><strong>一般用Edit Collider编辑</strong>，主要用于确定地形范围</td></tr><tr><td>胶囊碰撞器（Capsule Collider 2D）</td><td>胶囊的宽高（Size）&#x2F;  轴向（Direction）</td><td>胶囊体的半径 &#x2F; 高度 &#x2F; 在局部空间中的轴向</td></tr><tr><td>复合碰撞器（Composition Collider 2D）</td><td>几何学类型（Geometry Type：空心轮廓（Outlines）、实心多边形（Polygons）&#x2F;  生成类型（Generation Type）：对2D复合碰撞器或使用的其他碰撞器修改时，Unity立即生成新几何体（Sychronous）、手动生成，代码或点击按钮（Manual）&#x2F;  从复合碰撞器收集顶点时允许的最小间距值（Vertex Distance）</td><td>合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型：空心可以放在内部但实心不行 &#x2F; 复合碰撞器在何时生成新几何体 &#x2F; 控制碰撞器的准确度</td></tr></tbody></table><p><strong>注意：</strong> 复合碰撞器一定要配合刚体使用</p><h3 id="区别碰撞和触发"><a href="#区别碰撞和触发" class="headerlink" title="区别碰撞和触发"></a>区别碰撞和触发</h3><ol><li>碰撞：会产生实际的物理效果</li><li>触发：看起来不会产生碰撞，但是可以通过函数监听触发</li></ol><h3 id="响应函数"><a href="#响应函数" class="headerlink" title="响应函数"></a>响应函数</h3><p><strong>注意： 碰撞和触发响应函数属于特殊的生命周期函数，也是通过反射调用</strong><br>执行时机：只要挂载的对象能和别的物体产生碰撞或者触发，那么对应的这6个函数就都能被响应。<br>特殊情况：如果是一个异形物体，刚体在父对象上，不能通过子对象上挂载脚本检测碰撞，必须挂载到这个刚体父对象上。</p><h4 id="物理碰撞检测"><a href="#物理碰撞检测" class="headerlink" title="物理碰撞检测"></a>物理碰撞检测</h4><p><em>触碰时：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 碰撞后的执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Collision</code>类型的参数包含了碰到自己的对象的相关信息。<br>关键参数：</p><ol><li>碰撞到的对象碰撞器的信息：<code>collision.collider</code></li><li>碰撞对象的依附对象（GameObject）：<code>collision.gameObject</code></li><li>碰撞对象的依附对象的位置信息：<code>collision.transform</code></li><li>触碰点数相关：<code>collision.contactCount</code><br> 接触点具体的坐标：<code>ContactPoint[] pos = collision.contacts</code></li></ol><p><em>分离时：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 碰撞结束执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>相互接触摩擦时：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不停调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 相互接触摩擦时执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="触发器检测"><a href="#触发器检测" class="headerlink" title="触发器检测"></a>触发器检测</h4><p><em>触发时：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 触发时执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>结束时：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 水乳相融状态结束执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>正在触发时：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不停调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 水乳相融状态时执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑。一般会把想要重写的碰撞和触发函数写成保护类型的（没有必要写成 public，因为不会自己手动调用，都是Unity通过反射帮助我们自动调用的）。</p><h3 id="2D效应器"><a href="#2D效应器" class="headerlink" title="2D效应器"></a>2D效应器</h3><p>2D效应器是配合2D碰撞器一起使用，可以让游戏对象在相互接触时产生一些特殊的物理作用力，快捷的实现传送带、互斥、吸引、漂浮、单向碰撞等等效果。</p><p>要使一个物体变为效应器，需要添加2个组件：<strong>碰撞器（勾选Used By Editor、is Trigger）</strong> 和 <strong>效应器</strong></p><p>共有参数：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>是否启用碰撞器遮罩（Use Collidr Mask）</td><td>开启后可以选择控制碰撞器作用范围</td></tr><tr><td>阻力（区域、点：Drag、浮力：Linear Drag）</td><td>受到的移动阻力系数</td></tr><tr><td>扭矩阻力（Angular Drag）</td><td>受到的旋转阻力系数</td></tr><tr><td>施加力的角度（区域：Force Angle、浮力：Flow Angle）</td><td>物体进来时受到的力的角度</td></tr><tr><td>施加力的大小（区域、点：Force Magnitude、浮力：Flow Magnitude水平推动的力）</td><td>物体进来时受到的力的大小</td></tr><tr><td>施加力的随机大小变化（区域、点：Force Variation、浮力：Flow Variation）</td><td>对物体施加的力的大小变化范围</td></tr></tbody></table><p>特有参数：</p><table><thead><tr><th>效应器种类</th><th>主要作用</th><th>重要参数</th></tr></thead><tbody><tr><td>区域效应器Area Effector 2D</td><td>在一个区域内让游戏对象受到力和扭矩力的作用</td><td>1. 是否启用世界坐标系角度（Use Global Angle）：不勾选默认区域效应器角度；2. 施加力的作用点（Force Target）：刚体质心（不产生扭矩力）、碰撞器（有扭矩力）。</td></tr><tr><td>浮力效应器Buoyancy Effector 2D</td><td>模拟流体行为，浮动和阻力相关设置，让玩家看起来像在水里移动</td><td>1. 流体密度（Density）：密度越大，向上浮动的力越大；2. 浮力流体的表面位置（Surface Level）。</td></tr><tr><td>点效应器Point Effector 2D</td><td>模拟磁铁吸引或者排斥的效果</td><td>1. 效应器和目标之间距离的缩放（Distance Scale）：计算距离时，会按该比值对距离进行缩放；2. 力源（Force Source）；3. 施加力的作用点（Force Target）：刚体质心（不产生扭矩力）、碰撞器（有扭矩力）；4. 力的模式（Force Mode）：Constant：忽略源和目标之间相隔的距离；Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小；Inverse Squared：反平方距离，力的大小呈指数减小，类似显示世界重力。</td></tr><tr><td>平台效应器Platform Effector 2D（<strong>不做成触发器</strong>）</td><td>2D游戏当中的平台或可往上跳跃的墙壁</td><td>1. 旋转偏移量（Rotational Offset）：控制平台角度偏移；2. 是否使用单向碰撞行为（Use One Way）：可以从下方往上跳；3. 是否使用组合单向碰撞行为（Use One Way Grouping）；4. 不允许通过的表面（Surface Arc）；5. 是否在平台两侧使用摩擦（Use Side Friction）；6. 是否在平台两侧使用弹力（Use Side Bounce）；7. 左右两侧平台的响应弧度（Side Arc）。</td></tr><tr><td>表面效应器Surface Effector 2D（<strong>不做成触发器</strong>）</td><td>模拟传送带</td><td>1. 表面保持的速度（Speed）；2. 速度随机增加值（Speed Variation）；3. 力的缩放（Force Scale）：缩放沿表面移动时的力。0为不施加力，值越大，速度越快。不建议设置为1，可能会抵消物体上的其他力；4. 对接触物体表面的接触点施加力（Use Contact Force）：勾选后会让物体旋转；5. 是否使用摩擦力（Use Friction）；6. 是否使用弹力（Use Bounce）。</td></tr></tbody></table><h2 id="刚体加力"><a href="#刚体加力" class="headerlink" title="刚体加力"></a>刚体加力</h2><p><strong>给刚体加力的目标：</strong> 让其有一个速度，朝着某一个方向移动</p><h3 id="Rigidbody刚体组件"><a href="#Rigidbody刚体组件" class="headerlink" title="Rigidbody刚体组件"></a>Rigidbody刚体组件</h3><ol><li>核心功能：</li></ol><ul><li>赋予对象物理属性，遵循物理定律运动。</li><li>实现碰撞响应。</li><li>支持力、扭矩、速度等物理量控制，实现抛射、推动等效果。</li></ul><ol start="2"><li>关键参数</li></ol><table><thead><tr><th>关键参数</th><th>作用</th></tr></thead><tbody><tr><td>质量（Mass）</td><td>默认为kg，质量越大惯性越大</td></tr><tr><td>空气阻力（Drag）</td><td>值越大，物体减速越快</td></tr><tr><td>角速度拖动（Angular Drag）</td><td>旋转时的阻力，影响物体旋转减速速度</td></tr><tr><td><strong>是否受重力（Use Gravity）</strong></td><td><strong>勾选后对象受重力下落</strong></td></tr><tr><td>是否运动学（Is Kinematic）</td><td>勾选后不受物理引擎控制，仅通过代码或动画 HingeJoint 驱动</td></tr><tr><td>插值运算（Interpolate）</td><td>让刚体移动更平滑。<code>None</code>不应用；<code>Interpolate</code>根据前一帧的变换来平滑变换；<code>Extrapolate</code>根据下一帧的估计变换来平滑变换</td></tr><tr><td>碰撞检测模式（Collision Detection）</td><td>防止快速移动的对象穿过其他对象而不检测碰撞。<code>Discrete</code>：离散检测，性能消耗更低，但是可能存在问题；<code>Continuous</code>：连续检测，性能消耗更高，但比较准确。</td></tr><tr><td><strong>约束（Constraints）</strong></td><td><strong>对刚体运动的限制</strong></td></tr></tbody></table><ol start="3"><li>2D刚体组件</li></ol><p>2D刚体组件与3D刚体组件最大的区别是<code>Body Type</code>刚体类型不同。</p><ul><li>这是<code>Dynamic</code>动态的刚体类型对应的参数：</li></ul><table><thead><tr><th>特殊参数</th><th>作用</th></tr></thead><tbody><tr><td>物理材质（Material）</td><td>可以确定碰撞体和其他对象碰撞时的表现方式</td></tr><tr><td>Simulate</td><td>碰撞器、关节模拟物理效果</td></tr><tr><td>使用自动质量（Use Auto Mass）</td><td>是否使用自动质量</td></tr><tr><td>影响位置移动的阻力系数（Linear Dray）</td><td>值越大，阻力越大</td></tr><tr><td>影响旋转移动的阻力系数（Angular Dray）</td><td>值越大，阻力越大</td></tr><tr><td>受重力影响的程度（Gravity Scale）</td><td>值越大，受重力程度越大</td></tr><tr><td>睡眠模式（Sleeping  Mode）</td><td>刚体休眠（Never Sleep：从不休眠；Start Awake：最初唤醒； Start Asleep：最初睡眠，但可以被碰撞唤醒）</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>如果父物体上的刚体设置了物理材质，若子物体有碰撞器但是没有设置材质，则会用通用的刚体的物理材质。（查看通用物理材质：Edit -&gt; Project Settings -&gt; Physics 2D）</li><li>物理材质的使用优先级：碰撞器 -&gt; 刚体 -&gt; Physics 2D</li></ol><ul><li>这是<code>Kinematic</code>运动学类型的刚体类型对应的参数：</li></ul><p>特点：不受力的影响，只能通过代码让其动起来。能和动态2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数，因此它没有质量、摩擦系数等属性，性能消耗较低。</p><table><thead><tr><th>特殊参数</th><th>作用</th></tr></thead><tbody><tr><td>Simulate</td><td>碰撞器、关节模拟物理效果。运动学类型的刚体的特殊作用：启用后，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞。（如果<code>Use Full Kinematic Contacts</code> 禁用，他只会和动态刚体碰撞）</td></tr><tr><td>Use Full Kinematic Contacts</td><td>启用：和所有2D刚体碰撞；禁用：只能和动态刚体产生碰撞。</td></tr></tbody></table><ul><li>这是<code>Static</code>静态类型的刚体类型对应的参数：</li></ul><p>特点：完全不动的需要检测碰撞的对象。相当于无限质量不可移动的对象。性能消耗最小，只能和动态刚体碰撞。<strong>相当于只能检测动态刚体的碰撞器。</strong></p><p><strong>如何选择这3种刚体类型：</strong></p><ol><li><code>Dynamic</code>动态刚体：受力作用，要动要碰撞的对象</li><li><code>Kinematic</code>运动学刚体：通过刚体API移动的对象，不受力作用，但是想要进行碰撞检测。</li><li><code>Static</code>静态刚体：不动不受力作用的静态物体，但是想要进行碰撞检测。</li></ol><h3 id="刚体休眠"><a href="#刚体休眠" class="headerlink" title="刚体休眠"></a>刚体休眠</h3><ol><li>定义：Unity为了节约性能，会给刚体加一个休眠机制。在一定情况下不产生力的效果。</li><li>解决这个问题的方法：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取刚体是否处于休眠状态 如果是</span></span><br><span class="line"><span class="keyword">if</span>(rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 就唤醒它</span></span><br><span class="line">rigidBody.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><h4 id="施加力"><a href="#施加力" class="headerlink" title="施加力"></a>施加力</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取刚体组件</span></span><br><span class="line">Rigidbody rigidBody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加力</span></span><br><span class="line"><span class="comment">// 加力后对象是否停止移动 由阻力决定</span></span><br><span class="line">rigidBody.AddForce(Vector3.forward * <span class="number">10</span>); <span class="comment">// 相对于世界坐标系z轴正方向加了一个力</span></span><br><span class="line">rigidBody.AddForce(<span class="keyword">this</span>.transform.forward * <span class="number">10</span>); <span class="comment">// 相对于世界坐标系 对象朝自己的面朝向移动</span></span><br><span class="line">rigidBody.AddRelativeForce(Vector3.forward * <span class="number">10</span>); <span class="comment">// 相对于本地坐标</span></span><br></pre></td></tr></table></figure><p><code>AddForce</code> 有重载函数，第二个参数是力的模式，主要作用是改变计算方式，也因为计算方式不同，最终的移动速度不同。</p><table><thead><tr><th>力的模式</th><th>效果</th></tr></thead><tbody><tr><td>Acceleration</td><td>给物体施加一个持续的加速度，忽略其质量（m默认为1）</td></tr><tr><td>Force</td><td>给物体添加一个持续的力，与物体的质量有关</td></tr><tr><td>Impulse</td><td>给物体添加一个瞬间的力，与物体的质量有关，忽略时间（t默认为1）</td></tr><tr><td>VelocityChange</td><td>给物体添加一个瞬时速度（t默认为1），忽略质量（m默认为1）</td></tr></tbody></table><p>Unity中自带一个力场脚本：<code>Constant Force</code>，添加这个脚本后会有持续的力的效果。主要作用是控制场景上一个物体的不停移动和旋转。</p><p>参数：</p><ul><li><code>Force</code>：物理更新时（Edit -&gt; Project Setting -&gt; Time）施加于物体上的线性力</li><li><code>Relative Force</code>：物理更新时相对于刚体对象的坐标系施加线性力</li><li><code>Torque</code>：物理更新时施加的扭矩力</li></ul><h4 id="施加扭矩力"><a href="#施加扭矩力" class="headerlink" title="施加扭矩力"></a>施加扭矩力</h4><p><strong>作用：让其旋转</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对世界坐标</span></span><br><span class="line">rigidBody.AddTorque(Vector3.up * <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 相对本地坐标</span></span><br><span class="line">rigidBody.AddRelativeTorque(Vector3.forward * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="直接改变速度"><a href="#直接改变速度" class="headerlink" title="直接改变速度"></a>直接改变速度</h4><p>这个速度方向是相对于<strong>世界坐标系</strong>的：<code>rigidBody.velocity = Vector3.forward * 5;</code></p><h4 id="模拟爆炸效果"><a href="#模拟爆炸效果" class="headerlink" title="模拟爆炸效果"></a>模拟爆炸效果</h4><p><strong>注：</strong> 要得到所有希望产生爆炸效果影响的对象的刚体，来执行这个方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：受力大小</span></span><br><span class="line"><span class="comment">// 参数2：受力中心</span></span><br><span class="line"><span class="comment">// 参数3：受力半径</span></span><br><span class="line">rigidBody.AddExplosionForce(<span class="number">100</span>, Vector3.zero, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="范围检测"><a href="#范围检测" class="headerlink" title="范围检测"></a>范围检测</h1><p><strong>作用：</strong> 游戏中瞬时的攻击范围判断</p><h2 id="如何进行范围检测"><a href="#如何进行范围检测" class="headerlink" title="如何进行范围检测"></a>如何进行范围检测</h2><p><strong>必备条件：</strong> 想要被范围检测的对象必须具备碰撞器<br><strong>注意点：</strong></p><ol><li>相关API只有当执行该句代码时，进行一次范围检测，它是瞬时的。</li><li>相关API并不会产生一个碰撞器，只是碰撞判断计算而已。</li></ol><h3 id="范围检测API"><a href="#范围检测API" class="headerlink" title="范围检测API"></a>范围检测API</h3><h4 id="盒状范围检测-关于层级补充知识"><a href="#盒状范围检测-关于层级补充知识" class="headerlink" title="盒状范围检测( 关于层级补充知识 )"></a>盒状范围检测( 关于层级补充知识 )</h4><p><em>API1:</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：立方体的中心点</span></span><br><span class="line"><span class="comment">// 参数二：立方体三边大小</span></span><br><span class="line"><span class="comment">// 参数三：立方体角度</span></span><br><span class="line"><span class="comment">// 参数四：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数五：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：数组（在该范围内的触发器）</span></span><br><span class="line"></span><br><span class="line">Collider[] colliders = </span><br><span class="line">Physics.OverlapBox(Vector3.zero, <span class="keyword">new</span> Vector3(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), </span><br><span class="line">Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up),</span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) |</span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>), </span><br><span class="line">QueryTriggerInteraction.UseGlobal</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>补充知识：关于层级（重要）</strong><br>通过名字得到层级编号：<code>LayerMask.NameToLayer</code>。我们需要通过编号左移构建二进制数，这样每一个编号的层级都是对应位为1的2进制数，我们通过位运算可以选择想要检测层级。<br>好处：一个 int 就可以表示所有想要检测的层级信息。</p><p>层级编号是 0~31（32位，与int占位一致）：</p><p>每一个编号代表的都是二进制的一位：</p><table><thead><tr><th>层级</th><th>运算</th><th>2进制表示</th><th>2进制运算结果</th></tr></thead><tbody><tr><td>0层</td><td>1 &lt;&lt; 0</td><td>0000 0001</td><td>1</td></tr><tr><td>1层</td><td>1 &lt;&lt; 1</td><td>0000 0010</td><td>2</td></tr><tr><td>2层</td><td>1 &lt;&lt; 2</td><td>0000 0100</td><td>4</td></tr><tr><td>3层</td><td>1 &lt;&lt; 3</td><td>0000 1000</td><td>8</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>这样可以进行位运算，比如上面给出的例子是<code>0000 0001 | 0010 0000 = 0010 0001 = 33</code>，然后Unity内部进行<code>&amp;</code>运算来判断哪些层级要检测。</p><p><em>API2:</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：前面的参数和 API1 一样，后面需要传一个数组（碰撞到的东西）</span></span><br><span class="line"><span class="comment">// 返回值：一个int（碰撞到的碰撞器数量）</span></span><br><span class="line">Collider[] colliders;</span><br><span class="line">Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders)</span><br></pre></td></tr></table></figure><h4 id="球形范围检测"><a href="#球形范围检测" class="headerlink" title="球形范围检测"></a>球形范围检测</h4><p><em>API1:</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：中心点</span></span><br><span class="line"><span class="comment">// 参数2：球半径</span></span><br><span class="line"><span class="comment">// 参数3：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数4：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：一个数组（在该范围内的触发器）</span></span><br><span class="line">Physics.OverlapSphere(Vector3.zero, <span class="number">5</span>, </span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">QueryTriggerInteraction.UseGlobal</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>API2：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：前面的参数和 API1 一样，后面需要传一个数组（碰撞到的东西）</span></span><br><span class="line"><span class="comment">// 返回值：一个int（碰撞到的碰撞器数量）</span></span><br><span class="line">Collider[] colliders;</span><br><span class="line">Physics.OverlapSphereNonAlloc(Vector3.zero, Vector3.one, colliders)</span><br></pre></td></tr></table></figure><h4 id="胶囊范围检测"><a href="#胶囊范围检测" class="headerlink" title="胶囊范围检测"></a>胶囊范围检测</h4><p><em>API1:</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：半圆一中心点</span></span><br><span class="line"><span class="comment">// 参数2：半圆二中心点</span></span><br><span class="line"><span class="comment">// 参数3：半圆半径</span></span><br><span class="line"><span class="comment">// 参数4：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数5：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：一个数组（在该范围内的触发器）</span></span><br><span class="line">Physics.OverlapCapsule(Vector3.zero, Vector3.up, <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>),</span><br><span class="line">QueryTriggerInteraction.UseGlobal</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>API2:</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：前面的参数和 API1 一样，后面需要传一个数组（碰撞到的东西）</span></span><br><span class="line"><span class="comment">// 返回值：一个int（碰撞到的碰撞器数量）</span></span><br><span class="line">Collider[] colliders;</span><br><span class="line">Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, <span class="number">1</span>, colliders)</span><br></pre></td></tr></table></figure><hr><h1 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h1><p><strong>作用：</strong> 在指定点发射一个指定方向的射线，判断该射线与哪些碰撞器相交，得到相应对象。</p><h2 id="如何进行射线检测"><a href="#如何进行射线检测" class="headerlink" title="如何进行射线检测"></a>如何进行射线检测</h2><h3 id="声明射线对象"><a href="#声明射线对象" class="headerlink" title="声明射线对象"></a>声明射线对象</h3><ol><li>3D世界中的射线</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：起点</span></span><br><span class="line"><span class="comment">// 参数2：方向向量</span></span><br><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward); <span class="comment">// Ray是Unity中提供的一个类</span></span><br></pre></td></tr></table></figure><p><code>Ray</code>中的参数：<br>1. 起点：<code>r.origin</code><br>2. 方向：<code>r.direction</code></p><hr><ol start="2"><li>摄像机发射的射线</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起点：屏幕位置</span></span><br><span class="line"><span class="comment">// 方向：摄像机视口方向</span></span><br><span class="line">Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure><h3 id="射线碰撞检测"><a href="#射线碰撞检测" class="headerlink" title="射线碰撞检测"></a>射线碰撞检测</h3><p><strong>注意：</strong><br>1. 射线检测也是瞬时的，执行代码时进行一次射线检测。<br>2. 检测的最大距离 和 检测指定层级 都是int类型，传层级之前一定要传距离</p><h4 id="只检测是否碰撞到对象"><a href="#只检测是否碰撞到对象" class="headerlink" title="只检测是否碰撞到对象"></a>只检测是否碰撞到对象</h4><p><em>API1：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 准备一条射线</span></span><br><span class="line">Ray r3 = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.forward);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 进行射线检测</span></span><br><span class="line"><span class="comment">// 参数1：射线</span></span><br><span class="line"><span class="comment">// 参数2：检测的最大距离</span></span><br><span class="line"><span class="comment">// 参数3：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数4：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：bool (如果碰撞到对象 返回true，否则返回false)</span></span><br><span class="line"></span><br><span class="line">Physics.Raycast(r3, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><p><em>API1的等价形式 :</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把第一个参数射线 换成 射线的起点和方向</span></span><br><span class="line">Physics.Raycast(Vector3.zero, Vector3.forward, <span class="number">1000</span>, </span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><h4 id="获取相交的单个物体信息"><a href="#获取相交的单个物体信息" class="headerlink" title="获取相交的单个物体信息"></a>获取相交的单个物体信息</h4><p>API2与API1的区别在于多了一个<code>out hitInfo</code>信息<br><em>API2:</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物体信息类 RaycastHit</span></span><br><span class="line">RaycastHit hitInfo;</span><br><span class="line"><span class="comment">// 参数1：射线</span></span><br><span class="line"><span class="comment">// 参数2：RaycastHit是结构体（值类型）</span></span><br><span class="line"><span class="comment">// Unity会通过out关键词 在函数内部处理后得到碰撞数据后返回</span></span><br><span class="line"><span class="comment">// 参数3：检测的最大距离</span></span><br><span class="line"><span class="comment">// 参数4：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数5：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：bool (如果碰撞到对象 返回true，否则返回false)</span></span><br><span class="line"><span class="keyword">if</span>( Physics.Raycast(r3, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),</span><br><span class="line">QueryTriggerInteraction.UseGlobal) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// hitInfo中有碰撞到的物体的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RaycastHit</code>中的参数：<br>1. 碰撞器信息：<code>hitInfo.collider</code><br>2. 碰撞到的点：<code>hitInfo.point</code> 作用：在此处创建特效<br>3. 法线信息：<code>hitInfo.normal</code> 作用：使美术表现更写实，比如贴弹痕<br>4. 位置信息：<code>hitInfo.transform.position</code><br>5. 与碰撞到的对象的距离：<code>hitInfo.distance</code> 作用：处理距离远近对伤害的影响 &#x2F; 子弹抛物线</p><p><em>API2的等价形式：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Physics.Raycast(Vector3.zero, Vector3.forward, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>),</span><br><span class="line">QueryTriggerInteraction.UseGlobal)</span><br></pre></td></tr></table></figure><h4 id="获取相交的多个物体信息"><a href="#获取相交的多个物体信息" class="headerlink" title="获取相交的多个物体信息"></a>获取相交的多个物体信息</h4><p><em>API3:</em><br>作用：可以得到碰撞到的多个对象，如果没有就是容量为0的数组。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：射线</span></span><br><span class="line"><span class="comment">// 参数2：检测的最大距离</span></span><br><span class="line"><span class="comment">// 参数3：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数4：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：数组（存储所有碰撞到的物体的信息）</span></span><br><span class="line">RaycastHit[] hits = Physics.RaycastAll(r3, <span class="number">1000</span>, </span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><p><em>API3的等价形式：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll( Vector3.zero, Vector3.forward, <span class="number">1000</span>, </span><br><span class="line"><span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">QueryTriggerInteraction.UseGlobal );</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 存储信息的数组是一个栈</p><h4 id="获取相交的物体数量"><a href="#获取相交的物体数量" class="headerlink" title="获取相交的物体数量"></a>获取相交的物体数量</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：射线</span></span><br><span class="line"><span class="comment">// 参数2：碰撞到的物体信息的数组</span></span><br><span class="line"><span class="comment">// 参数3：检测的最大距离</span></span><br><span class="line"><span class="comment">// 参数4：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">// 参数5：是否忽略触发器（不填使用UseGlobal）</span></span><br><span class="line"><span class="comment">// UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器</span></span><br><span class="line"><span class="comment">// 返回值：int（相交的物体数量）</span></span><br><span class="line">Physics.RaycastNonAlloc(r3, hits, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), </span><br><span class="line">QueryTriggerInteraction.UseGlobal);)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这篇文章记录了Unity中物理系统相关（未完待续）</summary>
    
    
    
    <category term="Unity/核心系统" scheme="http://tymblog.yuzhiboliuhua.cn/categories/Unity-%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Unity" scheme="http://tymblog.yuzhiboliuhua.cn/tags/Unity/"/>
    
    <category term="物理系统" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/13675369.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/13675369.html</id>
    <published>2025-11-01T07:08:00.000Z</published>
    <updated>2026-02-14T08:35:09.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="C主框架"><a href="#C主框架" class="headerlink" title="C主框架"></a>C主框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>函数，又称主函数，是程序执行的起点。在执行程序时，由系统调用主函数，最后返回，结束程序。主要代码要写在主函数里。</p><p>主函数的类型一般是<code>int</code>，最后由<code>return</code>返回<code>0</code>来结束运行。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="C语言标准库"><a href="#C语言标准库" class="headerlink" title="C语言标准库"></a>C语言标准库</h3><p><code>stdio.h</code>是C语言标准库，提供了C语言最基本的语法以及一些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学函数库"><a href="#数学函数库" class="headerlink" title="数学函数库"></a>数学函数库</h3><p><code>math.h</code>里有大量关于数学操作的函数，可以用来更方便的解决问题。常用的有：</p><ul><li><p><code>abs()</code> 对整形数据取绝对值</p></li><li><p><code>fabs()</code> 对浮点型数据取绝对值</p></li><li><p><code>sqrt()</code> 对数据取平方根（<code>double</code>型）</p></li><li><p><code>pow(x, y)</code> 求x的y次幂（<code>double</code>型）</p></li></ul><h3 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h3><ul><li><p><code>string.h</code>中的函数主要用于对字符串进行操作,常用的函数有：</p></li><li><p><code>strlen()</code> 返回字符串的长度。</p></li><li><p><code>strcmp(x, y)</code> 比较字符串<code>x</code>和<code>y</code>。当<code>x &lt; y</code>，返回值小于<code>0</code>；当<code>x = y</code>，返回值等于<code>0</code>；当<code>x &gt; y</code>，返回值大于<code>0</code>。</p></li><li><p><code>strcpy(x, y)</code> 将<code>y</code>指向的字符复制到<code>x</code>中</p></li><li><p><code>strcat(x, y)</code> 将字符串<code>y</code>连接到<code>x</code>的尾部</p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p><code>//</code> 单行注释</p></li><li><p><code>/**/</code> 整段注释</p></li></ul><h2 id="define-定义标识符"><a href="#define-定义标识符" class="headerlink" title="#define 定义标识符"></a>#define 定义标识符</h2><p>C语言中可以使用<code>#define</code>来定义一个标识符来表示一个常量,或定义一些宏，定义的标识符,并不占用程序内存,在预编译阶段对程序代码进行文本替换。定义标识符的操作在主函数外面。</p><p>最常见的用法就是<code>#define</code>来定义一些常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI = 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆周率 = %d&quot;</span>, PI);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="typedef-关键字定义"><a href="#typedef-关键字定义" class="headerlink" title="typedef 关键字定义"></a>typedef 关键字定义</h2><p>C语言允许用户使用 <code>typedef</code> 关键字来定义自己习惯的数据类型名称，<code>typedef</code> 的真正含义是给一个已经存在的类型名称起一个别名，注意是已经存在的数据类型，而非变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LL a = <span class="number">12345678</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="定义和赋值"><a href="#定义和赋值" class="headerlink" title="定义和赋值"></a>定义和赋值</h2><p><strong>定义：</strong><code>数据类型</code> <code>数据名</code> <code>;</code></p><p><strong>定义时赋初值：</strong><code>数据类型</code> <code>数据名</code> <code>赋值符号（=）</code> <code>初值</code> <code>;</code></p><p><strong>同时定义多个：</strong><code>数据类型</code> <code>数据名</code> <code>,</code> <code>数据名</code> <code>;</code></p><p><strong>注意！</strong> 定义时没有赋初值的话这个数据的值就是随机的，有需要时千万别忘了赋初值，没有需要时也赋初值也是一个很好的习惯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.14</span>, d = <span class="number">2.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %lf&quot;</span>, a, b, c, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：<br><code>0 5 3.14 2.2</code></p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>在程序运行的过程中，可以改变值的变量称为变量。</p><p>程序运行过程中，不可以发生改变的量叫做常量。</p><p>一般定义的数据默认为变量，可以用<code>define</code>定义常量，也可以在定义时的数据类型前加上<code>const</code>使之成为常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3</span>,<span class="number">1415926</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><table><thead><tr><th align="left"></th><th>类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td align="left"><strong>char</strong></td><td>字符型</td><td>1字节</td><td>-128 到 127</td></tr><tr><td align="left"><strong>short</strong></td><td>短整型</td><td>2字节</td><td>-32,768 到 32,767</td></tr><tr><td align="left"><strong>int</strong></td><td>整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left"><strong>long</strong></td><td>长整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left"><strong>long long</strong></td><td>长长整形</td><td>8字节</td><td></td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th></th><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td><strong>float</strong></td><td>单精度浮点数</td><td>4字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td><strong>double</strong></td><td>双精度浮点数</td><td>8字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td><strong>long double</strong></td><td>长双精度浮点数</td><td>16字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19位有效位</td></tr></tbody></table><h3 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h3><p>整型变量的值的范围包括负数到正数。</p><p>但是在实际应用中，有的数据的范围常常只有<em>正值</em>（如学号、年龄等），为了充分利用变量的值的范围，可以将变量定义为“无符号”类型。可以在类型符号前面加上修饰符 <code>unsigned</code> ，表示指定该变量是“<em>无符号整数</em>”类型。如果加上修饰符 <code>signed</code>或什么都不加，则是“<em>有符号</em>”类型。</p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><strong>布尔类型</strong>是一种包含两种值的数据类型，即<code>0</code>和<code>1</code>。基本上，<code>bool</code>类型的值表示两种行为，即<code>true</code>或<code>false</code>。在这里，’<code>0&#39;</code>表示<code>false</code>值，而’<code>1</code>‘表示<code>true</code>值。</p><p><strong>在C中，<code>&#39;0&#39;</code> 以<code>0</code>的形式存储，而其他整数以<code>1</code>的形式存储,即“非零即true”</strong></p><p>C语言标准库不自带<strong>bool</strong>类型，需要引用<code>stdbool.h</code>头文件：<br><code>#include&lt;stdbool.h&gt; </code></p><p>有符号整型数据存储单元中最高位代表数值的符号，如果指定为无符号型，不能存放负数，如 -123 等。由于无符号整型变量不用符号位，所以可表示数值的范围是一般整型变量中的两倍。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><a href="%5BC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%7B%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98&%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98&%E5%A0%86%E6%A0%88%7D_c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/xiandang8023/article/details/126036564)">内存分配-CSDN</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在进行运算时，不同类型的数据要转换成同一类型。</p><h3 id="自动类型转换（隐式类型转换）"><a href="#自动类型转换（隐式类型转换）" class="headerlink" title="自动类型转换（隐式类型转换）"></a>自动类型转换（隐式类型转换）</h3><ul><li><p><code>float</code>型数据自动转换成<code>double</code>型；</p></li><li><p><code>char</code>与<code>short</code>型数据自动转换成<code>int</code>型；</p></li><li><p><code>int</code>型与<code>double</code>型数据运算，直接将<code>int</code>型转换成<code>double</code>型</p></li><li><p><code>int</code>型与<code>unsigned</code>型数据、直接将<code>int</code>型转换成<code>unsigned</code>型；</p></li><li><p><code>int</code>型与<code>long</code>型数据，直接将<code>int</code>型转换成<code>long</code>型。</p></li></ul><p>如此等等，总之是由低级向高级型转换。另外不要错误地理解为先将<code>char</code>型或<code>short</code>型转换成<code>int</code>型，再转换成<code>unsigned</code>型，再转换成<code>long</code>型，直至<code>double</code>型。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换的一般形式为：<code>（类型名）</code> <code>（表达式）</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">7</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> y1, y2;</span><br><span class="line"><span class="type">float</span> y1 = a / b; <span class="comment">// y1的值a/b为3.0</span></span><br><span class="line">y2 = (<span class="type">float</span>) (a / b); <span class="comment">// y2的值为3.5， float将a强制转换为实型，b也随之自动转换为实型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>每个字符都对应着一个ASCII码：<a href="https://www.runoob.com/w3cnote/ascii.html">ASCII码表</a><br><strong>常用：</strong></p><p><code>0</code> -&gt; <code>48</code></p><p><code>9</code> -&gt; <code>57</code></p><p><code>A</code> -&gt; <code>65</code></p><p><code>Z</code> -&gt; <code>90</code></p><p><code>a</code> -&gt; <code>97</code></p><p><code>z</code> -&gt; <code>122</code></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><strong>十进制：</strong> 默认数制</p><p><strong>二进制：</strong> 以<code>0B</code>或<code>0b</code>前缀表示，如<code>0b0101</code></p><p><strong>八进制：</strong> 以<code>0</code>前缀表示，如<code>0123</code></p><p><strong>十六进制：</strong> 以<code>0X</code>或<code>0x</code>前缀表示，如<code>0x1A</code></p><p><strong>vc6.0中整形后加<code>l</code>或<code>L</code>表示是<code>long</code>型，加<code>u</code>表示是<code>unsigned</code>型</strong></p><hr><h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>在C语言中，程序的执行分为三种结构：顺序结构、选择结构（分支结构）和循环结构。</p><p>顺序结构：代码从上到下顺序执行，中间没有任何判断和跳转。</p><h2 id="变量输入输出"><a href="#变量输入输出" class="headerlink" title="变量输入输出"></a>变量输入输出</h2><p>在C语言中，输入和输出是通过库函数<code>stdio.h</code>中的<code>scanf()</code>和<code>printf()</code>函数来实现的。在输入与输出时，<code>printf()</code>函数与<code>scanf()</code>函数的格式字符串用于指定输入输出的格式。格式字符串中的格式说明符（如<code>%d</code>表示整数，<code>%f</code>表示浮点数）必须与后面参数的类型和数量相匹配。如果格式字符串与参数不匹配，可能会导致未定义的行为或输出错误。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>C语言中的表达式主要由运算符和操作数构成。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><strong>算术运算符</strong>：<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></li><li><strong>赋值运算符</strong>：C语言中的赋值运算符<code>=</code>用于将一个表达式的值赋给变量。此外，C语言还支持复合赋值运算符，如<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code> 等，这些运算符可以简化赋值和算术运算的组合。</li><li><strong>自增自减运算符</strong>：C语言中的自增<code>++</code>和自减 <code>--</code> 运算符用于将变量的值增加或减少1。这些运算符只能用于变量，不能用于常量或表达式。</li><li><strong>位运算符</strong>：</li></ul><table><thead><tr><th>位运算符</th><th>名称</th><th>规则</th></tr></thead><tbody><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>将 <code>a</code> 的二进制位向左移动 <code>n</code> 位，右侧补 <code>0</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>向右移动 <code>n</code> 位，左侧补符号位（正数补 <code>0</code>，负数补 <code>1</code>）</td></tr><tr><td><code>^</code></td><td>异或</td><td>对应位不同时，结果为 <code>1</code>；相同则为 <code>0</code></td></tr><tr><td><code>&amp;</code></td><td>与</td><td>对应位不同时，结果为 <code>1</code>；相同则为 <code>0</code></td></tr><tr><td><code>|</code></td><td>或</td><td>对应位至少有一个为 <code>1</code> 时，结果为 <code>1</code>；否则为 <code>0</code></td></tr></tbody></table><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在C语言中，运算符的优先级决定了表达式中各个运算对象之间的计算顺序，即哪个部分先计算，哪个部分后计算。下面是C语言中常用的运算符优先级列表，从高到低排列：</p><ol><li>括号 <code>()</code></li><li>一元运算符：<code>++</code> <code>- -</code> <code>!</code></li><li>算术运算符：<code>*</code> <code>/</code> <code>%</code></li><li>算术运算符：<code>+</code> <code>-</code></li><li>关系运算符：<code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></li><li>等价运算符：<code>==</code> <code>!=</code></li><li>位运算符：<code>&lt;&lt;</code> <code>&gt;&gt;</code></li><li>位运算符：<code>&amp;</code></li><li>位运算符：<code>^</code></li><li>位运算符：<code>|</code></li><li>条件运算符 <code>?:</code></li><li>赋值运算符：<code>=</code> <code>+=</code> <code>-=</code> </li><li>逗号运算符: <code>,</code></li></ol><p>需要注意的是，同一优先级的运算符按照结合性进行计算，大部分运算符遵循<strong>从左至右</strong>的结合性，只有<strong>单目运算符</strong>、<strong>条件运算符</strong>、<strong>赋值运算符</strong>遵循<strong>从右至左</strong>的结合性。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C语言中的语句可以分为以下几类：</p><ul><li><strong>表达式语句</strong>：由表达式加上分号<code>;</code>组成，用于计算表达式的值并执行副作用。</li><li><strong>函数调用语句</strong>：由函数名、实际参数加上分号<code>;</code>组成，用于调用函数。</li><li><strong>控制语句</strong>：用于控制程序的执行流程，包括条件判断、循环执行、转向等。</li><li><strong>复合语句</strong>：用花括号<code>&#123;&#125;</code>括起来的一条或多条语句，也称为块。</li><li><strong>空语句</strong>：只有分号<code>;</code>组成的语句，不执行任何操作的语句。</li></ul><hr><h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if-else-判断结构"><a href="#if-else-判断结构" class="headerlink" title="if-else 判断结构"></a>if-else 判断结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)</span><br><span class="line">    a += b + <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><code>&lt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></p><p>​ <code>!=</code> 用于测试“不相等”</p><p>​ <code>==</code> 用于测试“相等”</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><code>||</code>或 <code>&amp;&amp;</code> 且 <code>!</code> 非</p><h2 id="switch-case选择结构"><a href="#switch-case选择结构" class="headerlink" title="switch-case选择结构"></a>switch-case选择结构</h2><p><code>switch-case</code>语句一般搭配<code>break</code>和<code>default</code>使用。</p><p>中断语句<code>break</code>是C语言中的关键字，用于跳出循环或<code>switch</code>语句的执行。<code>break</code>语句通常用于在满足某个条件时提前终止循环，或在<code>switch</code>语句中匹配到某个<code>case</code>后跳出。</p><p>当 <code>switch</code> 表达式的值并不匹配所有 <code>case</code> 标签的值时，这个 <code>default</code> 子句后面的语句就会执行，<code>switch</code> 语句可以有一个可选的 <code>default</code> <code>case</code>，出现在 <code>switch</code> 的结尾。<code>default</code> <code>case</code> 可用于在上面所有 <code>case</code> 都不为真时执行一个任务。<code>default</code> <code>case</code> 中的 <code>break</code> 语句不是必需的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (day)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注</strong>：C语言中的<code>switch</code>语句具有“穿透”性，这意味着如果在<code>switch case</code>中没有使用<code>break</code>语句，那么匹配的<code>case</code>之后的所有<code>case</code>都将被执行。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c;</span><br></pre></td></tr></table></figure><p>意为若a成立，则执行b，否则执行c。</p><p>三目运算符有很多用法，如判断赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = a &gt; b ? a : b; <span class="comment">// x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用三目运算符求出了a与b的最大值并赋给x，相较于</span></span><br><span class="line"><span class="comment">if (a &gt; b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    x = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    x = b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">要简单。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a * <span class="number">2</span> : b + a + b / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句具有在某些条件满足的情况下，反复执行特定代码的功能。</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p><code>do while</code> 循环是先直接进⼊循环体，执⾏循环语句，然后再执⾏ <code>while</code> 后的判断表达式，表达式为真，就会进⾏下⼀次，表达式为假，则不再继续循环。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break、continue"><a href="#break、continue" class="headerlink" title="break、continue"></a>break、continue</h2><p>在循环执行的过程中，如果某些状况发⽣的时候，需要提前终止循环，这是非常常见的现象。C语言中提供了 <code>break</code> 和 <code>continue</code> 两个关键字，就是应⽤到循环中的。</p><p><code>break</code> 的作用是用于永久的终止循环，只要 <code>break</code> 被执行，直接就会跳出循环，继续往后执行。</p><p><code>continue</code> 的作用是跳过本次循环 <code>continue</code> 后边的代码，在 <code>for</code>循环和 <code>while</code> 循环中有所差异的。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>分支结构和循环结构在使用中都可以嵌套，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">        <span class="type">int</span> Flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (Flag) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            Flag++;</span><br><span class="line">            <span class="keyword">if</span> (Flag &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">-100</span>;</span><br><span class="line">                </span><br><span class="line">                Flag++;</span><br><span class="line">                <span class="keyword">if</span> (Flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 1\r\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 0\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数</strong>是指将一组能完成一个功能或多个功能的语句放在一起的<strong>代码结构</strong>。在C语言程序中，至少会包含一个函数，即主函数<code>main()</code>。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>​ 库函数就是存放在函数库中的函数，具有明确的功能、入口调用参数和返回值。</p><p>​ <strong>库函数必须知道的一个秘密就是：使用库函数，必须包含 #include 对应的头文件。</strong></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>​ 自定义函数和库函数一样，有函数名，返回值类型和函数参数。</p><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p><ul><li><p>在函数或块内部的<strong>局部</strong>变量</p></li><li><p>在所有函数外部的<strong>全局</strong>变量</p></li><li><p>在<strong>形式</strong>参数的函数参数定义中</p></li></ul><p>在某个函数或块的内部声明的变量称为<strong>局部变量</strong>。它们只能被该函数或该代码块内部的语句使用。<strong>局部变量</strong>在函数外部是不可知的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// a，b，c，sum都是main函数的局部变量</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i ++ )</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> d;</span><br><span class="line">      d = i * <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">      sum += d;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// i，d是for语句中的局部变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;sum = %d&quot;</span>, sum);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>全局变量</strong>是定义在主函数外部，通常是在程序的顶部。<strong>全局变量</strong>在整个程序生命周期内都是有效的，在任意的函数内部能访问<strong>全局变量</strong>。</p><p>全局变量可以被任何函数或语句访问。也就是说，全局变量在声明后整个程序中都是可用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>全局变量在定义时默认初值为0</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://www.runoob.com/cprogramming/c-recursion.html">递归-菜鸟教程</a></p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组</strong>是一种<strong>数据结构</strong>，它可以存储一个固定大小的相同类型元素的<strong>顺序集合</strong>。数组中的元素可以通过索引访问，<strong>索引通常从0开始</strong>。</p><h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 声明一个整型数组，其中包含5个元素，未初始化</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个整型数组，并初始化</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明并初始化一个整型数组</span></span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = arr[<span class="number">3</span>]; <span class="comment">// a = 4</span></span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">n[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">n[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">n[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">n[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">n[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">n[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">n[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">n[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">n[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure><h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>数组长度可以使用 <code>sizeof</code> 运算符来获取数组的长度，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// 获取数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组长度为: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：<br><code>数组长度为: 5</code></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C 语言支持多维数组。多维数组声明的一般形式如下：<br><code>type name[size1][size2]...[sizeN];</code><br>多维数组最简单的形式是<strong>二维数组</strong>。一个二维数组，在本质上，是一个一维数组的列表。</p><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><p>多维数组可以通过在括号内为每行指定值来进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样也是一样的：<br><code>int a[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</code></p><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>嵌套的两个循环</p><hr><h1 id="字符串（字符数组）"><a href="#字符串（字符数组）" class="headerlink" title="字符串（字符数组）"></a>字符串（字符数组）</h1><p>字符串实际上是使用空字符 <code>\0</code> 结尾的一维字符数组。因此，字符串的实际长度总要多一位，<code>\0</code> 是用于标记字符串的结束。在定义一个字符串时不需要把 <code>\0</code>字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 <code>\0</code> 放在字符串的末尾。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在C语言中，转义字符是以反斜杠<code>\</code>开头，后跟一个字符。它用来表示非打印字符，比如换行<code>\n</code>以及其他一些特殊的字符。</p><p>以下是C语言中常用的转义字符的完整列表：</p><p><code>\\</code>：反斜杠<br><code>\&#39;</code>：单引号<br><code>\&quot;</code>：双引号<br><code>\?</code>：问号<br><code>\a</code>：警报（响铃）<br><code>\b</code>：退格<br><code>\f</code>：换页<br><code>\n</code>：换行<br><code>\r</code>：回车<br><code>\t</code>：制表符（水平制表）<br><code>\v</code>：垂直制表<br><code>\0</code>：空字符<br><code>\ooo</code>：八进制表示的字符（其中 ooo 是一个八进制数，范围为 0-377）<br><code>\xhh</code>：十六进制表示的字符（其中 hh 是一个十六进制数，范围为 00-FF）</p><h2 id="定义与赋值"><a href="#定义与赋值" class="headerlink" title="定义与赋值"></a>定义与赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>实际上，字符串就是char类型的数组，各种操作都与数组大同小异。</strong></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>字符串用<code>%s</code>输入输出，且输入时不用加取地址符<code>&amp;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> ch[<span class="number">11</span>] = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> ch2[<span class="number">11</span>] = <span class="string">&quot;javatpoint&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Char Array Value is: %s\n&quot;</span>, ch);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;String Literal Value is: %s\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Char Array Value is: javatpoint</span><br><span class="line">String Literal Value is: javatpoint</span><br></pre></td></tr></table></figure><p><strong>注</strong></p><ul><li><code>getchar()</code><br>读取一个字符，包括任何字符。</li><li><code>gets()</code><br>读取整行输入，直至遇到换行符，然后把换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。</li></ul><ol><li><code>gets()</code>函数不安全。  </li><li>C11标准委员会已经将其废除，建议能不用尽量不用。</li></ol><hr><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><a href="https://www.runoob.com/cprogramming/c-pointers.html">指针-菜鸟教程</a><br><a href="https://blog.csdn.net/u012060033/article/details/127600005">指针-CSDN</a></p><h2 id="取地址符"><a href="#取地址符" class="headerlink" title="取地址符"></a>取地址符</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <code>&amp;</code> 运算符访问的地址，它表示了在内存中的一个地址。</p><h2 id="取内容符"><a href="#取内容符" class="headerlink" title="取内容符"></a>取内容符</h2><p>符号<code>*</code>可以访问地址里面的内容。</p><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。</p><h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><p><strong>传递指针给函数</strong></p><p>C 语言允许传递指针给函数，只需要简单地 <strong>声明函数参数为指针类型</strong> 即可。</p><hr><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体（<code>struct</code>）是一种构造类型，它可以将不同的数据类型组合在一起形成一个新的数据类型，这种新的数据类型就是结构体。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>使用typedef定义别名，然后创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; Student;</span><br><span class="line"> </span><br><span class="line">Student stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><p>使用指针访问结构体成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*p).name); <span class="comment">// 使用指针访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name); <span class="comment">// 另一种访问结构体成员的方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="链表-结构体指针"><a href="#链表-结构体指针" class="headerlink" title="链表-结构体指针"></a>链表-结构体指针</h2><p><a href="https://blog.csdn.net/Ruaaa_iiiiiiiii/article/details/129499703">结构体链表</a></p><p>—end—</p>]]></content>
    
    
    <summary type="html">这篇文章是关于C语言的笔记，并不完善，仅供个人学习。</summary>
    
    
    
    <category term="高级编程语言/C" scheme="http://tymblog.yuzhiboliuhua.cn/categories/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-C/"/>
    
    
    <category term="C" scheme="http://tymblog.yuzhiboliuhua.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/d95d7e09.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/d95d7e09.html</id>
    <published>2025-11-01T06:07:45.722Z</published>
    <updated>2026-02-27T14:09:19.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>我的笔名叫做大鱼飞九草，来自四川成都。平时喜欢追番、打游戏，喜欢的运动是羽毛球乒乓球，性格ISFJ的金牛座一枚。<br>现在的我是一名计科院的大一学生，在团队师傅的指导下搭建了一个属于自己的博客，在接下来的时间里，我希望能够通过博客学习到更多知识，及时记录下自己的想法与收获。</p><hr><h1 id="我的心得"><a href="#我的心得" class="headerlink" title="我的心得"></a>我的心得</h1><h2 id="回顾这一年"><a href="#回顾这一年" class="headerlink" title="回顾这一年"></a>回顾这一年</h2><p>去年的这个时候，我还是一名将要迎来高考的高中生，饱含着对未来的期待与憧憬，一步一步走过高考，迎来了我的新的人生阶段。老实说，我过去完全没有了解过任何专业，仅在填报志愿的阶段查了很多资料便匆匆决定了我这一生的职业方向。（虽然也可能是“现在埋头苦干，毕业街头炒饭”hhh）这样的决定有些仓促，但也是经过当时的我的再三比较之后的决定。既然决定了，就不要后悔，踏踏实实地走好我为自己选择的人生之路。</p><p>在高考后的那个暑假，我得知了学校将在开学时进行团队考试，即便如此，我依然决定珍惜我这个来之不易的假期，及时行乐一番。然而，开学后我便有些后悔，虽然尽力地补救学习了一些，不过距离预设的考试范围我还是差的太多了。团队考试将至，我对自己的实力实在是没有信心，考了自己填报的第一志愿便不愿再去尝试了。团队录取结果渐渐公布，当我发现身边和我实力相当的同学一个个都进了团队，我有些懊悔，有些失落，不过更多的是后悔自己为什么不愿意相信自己，再多尝试尝试。不过一招已经结束，我决定参加团队的二招考试，这一次，我要夺回属于我的一切。。。</p><p>时间流逝，到了大一下，二招考试陆续开始，我几乎参加了所有二招考试，也几乎全都进了面试环节，不过前几个面试都被刷下来了，我又有些怀疑自己，究竟是我的实力不够？还是表达能力不行？还是说情商太低了？当局者迷，旁观者清。我将自己的经历分享给我在团队的朋友，告诉她我的面试过程，她给了我一些建议，我感觉确实在理，按照她的建议进行了一些改进，再通过自己的反思总结，想出了一些应对面试的措施。不久后，又迎来一次面试，我将这段时间自己总结的面试技巧全都用上了，我终于如愿以偿地进入了团队。值得一提的是，这个团队是我一招的第一志愿，是我想考入但是没考入的那个团队。之前的遗憾在此刻化为喜悦，我终于进入了梦寐以求的地方。</p><p>不过，进入团队后新的挑战来临。起初我并不是一个会学习的人，还沿用着高中那一套思维，不过因为团队伙伴的帮助，有了自己确定的目标和应该为之努力的方向，选择性地放下一些东西，把更多的精力投入到学习技术之中。但是事与愿违，逐渐我发现自己有些安排不过来自己的生活，整日忙忙碌碌，不过进展却不如人意，我选择放松一下，再好好调整调整，经过一个周末的反思，我逐渐调整好状态，继续投入新的学习生活中。然而，事情也并不会一帆风顺，其间我遇到了很多很多烦心事，当时确实有些崩溃，不过尽力沉住气，一件一件地解决，也算是有个好的结果。</p><p>作为一个真·电脑小白，起初我甚至将东西存在c盘，到了这个学期，我才开始关注我的电脑，整日折腾我的电脑与我自己，终于稍微了解了一些电脑的内部结构，我感觉自己认识了一位一直在身边的新朋友，是我熟悉又陌生的人。</p><h2 id="我的体会"><a href="#我的体会" class="headerlink" title="我的体会"></a>我的体会</h2><p>1.要有自信。很多事情要敢于尝试，即使结果不如人意也要有敢于尝试的勇气。</p><p>2.戒骄戒躁。面对很多件堆在一起的烦心事，不要自暴自弃，一件一件慢慢来做，最终总会有收获 。</p><p>3.明白自己要的是什么。有舍有得，敢于放弃一些事，才能收获更重要的。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当初临时的决定竟然将决定我的一生，不论前途多么坎坷，总需要面对，也正因这般坎坷，我们才会有所成长。除此之外，还应感谢这一路上给予我帮助的同伴，因为你们，我才有了面对这充满起伏的人生之旅的勇气。</p><p>-end-</p>]]></content>
    
    
    <summary type="html">欢迎光临我的博客！！在这里我将记录我的学习生活，有时也会更新一些自己的心得体会，大家可以随时来看看QvQ</summary>
    
    
    
    <category term="个人经历/日记" scheme="http://tymblog.yuzhiboliuhua.cn/categories/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86-%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="个人日记" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图片更新及文章更新</title>
    <link href="http://tymblog.yuzhiboliuhua.cn/posts/d787c39e.html"/>
    <id>http://tymblog.yuzhiboliuhua.cn/posts/d787c39e.html</id>
    <published>2025-09-12T04:12:00.000Z</published>
    <updated>2026-02-14T08:21:46.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片更新"><a href="#图片更新" class="headerlink" title="图片更新"></a>图片更新</h1><h2 id="上传图片到仓库中"><a href="#上传图片到仓库中" class="headerlink" title="上传图片到仓库中"></a>上传图片到仓库中</h2><p>打开hithub，选择图片库<br><img src="https://tymimg.yuzhiboliuhua.cn/post1/1.jpeg"><br><img src="https://tymimg.yuzhiboliuhua.cn/post1/1.jpeg"><br><img src="https://tymimg.yuzhiboliuhua.cn/post1/2.jpeg"><br><img src="https://tymimg.yuzhiboliuhua.cn/post1/3.jpeg"><br>拖拽图片到箭头指向位置，再点击commit changes即可<br><img src="https://tymimg.yuzhiboliuhua.cn/post1/4.jpeg"><br><strong>文章内更新：要用Markdown语法填写图片链接</strong></p><h2 id="修改顶图"><a href="#修改顶图" class="headerlink" title="修改顶图"></a>修改顶图</h2><p>在VSCode中用Ctrl + F 快捷键打开搜索top，修改地址<br><img src="https://tymimg.yuzhiboliuhua.cn/post1/5.jpeg"></p><hr><h1 id="更新文章"><a href="#更新文章" class="headerlink" title="更新文章"></a>更新文章</h1><p>1<br>在此目录下找到obsidian，在obsidian新建文件，注意文件名只能是英文<br><img src="https://tymimg.yuzhiboliuhua.cn/post1/6.jpeg"><br>打开源码模式<br><img src="https://tymimg.yuzhiboliuhua.cn/post1/7.jpeg"><br><img src="https://tymimg.yuzhiboliuhua.cn/post1/8.jpeg"><br>复制这一段进行修改<br><img src="https://tymimg.yuzhiboliuhua.cn/post1/9.jpeg"><br>改变：hexo g<br>预览：hexo s   <strong>记得关闭：ctrl + c</strong></p><p><img src="https://tymimg.yuzhiboliuhua.cn/post1/10.jpeg"><br>更改绿色部分点击提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">im good</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">从0开始搭建博客，这篇文章用于记录更新博客相关的一些操作。</summary>
    
    
    
    <category term="blog" scheme="http://tymblog.yuzhiboliuhua.cn/categories/blog/"/>
    
    
    <category term="博客" scheme="http://tymblog.yuzhiboliuhua.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
